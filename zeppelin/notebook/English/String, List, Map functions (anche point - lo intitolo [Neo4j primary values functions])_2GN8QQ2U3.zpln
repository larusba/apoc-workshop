{
  "paragraphs": [
    {
      "text": "%md\n\n# Collection and map functions",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:45:12.619",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eCollection and map functions\u003c/h1\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349487755_663980320",
      "id": "paragraph_1635349487755_663980320",
      "dateCreated": "2021-10-27 15:44:47.756",
      "dateStarted": "2021-10-27 15:45:12.619",
      "dateFinished": "2021-10-27 15:45:12.637",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d Text function\nhttps://neo4j.com/labs/apoc/4.1/misc/text-functions/\n// there are a bunch of useful text functions\n\n\n\n[[text-functions-overview]]\n\u003d\u003d Overview Text Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| xref::overview/apoc.text/apoc.text.indexOf.adoc[apoc.text.indexOf(text, lookup, offset\u003d0, to\u003d-1\u003d\u003dlen)] | find the first occurence of the lookup string in the text, from inclusive, to exclusive,, -1 if not found, null if text is null.\n| xref::overview/apoc.text/apoc.text.indexesOf.adoc[apoc.text.indexesOf(text, lookup, from\u003d0, to\u003d-1\u003d\u003dlen)] | finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.\n| xref::overview/apoc.text/apoc.text.replace.adoc[apoc.text.replace(text, regex, replacement)] | replace each substring of the given string that matches the given regular expression with the given replacement.\n| xref::overview/apoc.text/apoc.text.regexGroups.adoc[apoc.text.regexGroups(text, regex)] | returns an array containing a nested array for each match. The inner array contains all match groups.\n| xref::overview/apoc.text/apoc.text.join.adoc[+++apoc.text.join([\u0027text1\u0027,\u0027text2\u0027,...], delimiter)+++] | join the given strings with the given delimiter.\n| xref::overview/apoc.text/apoc.text.repeat.adoc[apoc.text.repeat(\u0027item\u0027,count)] | multiply the given string with the given count\n| xref::overview/apoc.text/apoc.text.format.adoc[apoc.text.format(text,[params],language)] | sprintf format the string with the params given, and optional param language (default value is \u0027en\u0027).\n| xref::overview/apoc.text/apoc.text.lpad.adoc[apoc.text.lpad(text,count,delim)] | left pad the string to the given width\n| xref::overview/apoc.text/apoc.text.rpad.adoc[apoc.text.rpad(text,count,delim)] | right pad the string to the given width\n| xref::overview/apoc.text/apoc.text.random.adoc[apoc.text.random(length, [valid])] | returns a random string to the specified length\n| xref::overview/apoc.text/apoc.text.capitalize.adoc[apoc.text.capitalize(text)] | capitalise the first letter of the word\n| xref::overview/apoc.text/apoc.text.capitalizeAll.adoc[apoc.text.capitalizeAll(text)] | capitalise the first letter of every word in the text\n| xref::overview/apoc.text/apoc.text.decapitalize.adoc[apoc.text.decapitalize(text)] | decapitalize the first letter of the word\n| xref::overview/apoc.text/apoc.text.decapitalizeAll.adoc[apoc.text.decapitalizeAll(text)] | decapitalize the first letter of all words\n| xref::overview/apoc.text/apoc.text.swapCase.adoc[apoc.text.swapCase(text)] | Swap the case of a string\n| xref::overview/apoc.text/apoc.text.camelCase.adoc[apoc.text.camelCase(text)] | Convert a string to camelCase\n| xref::overview/apoc.text/apoc.text.upperCamelCase.adoc[apoc.text.upperCamelCase(text)] | Convert a string to UpperCamelCase\n| xref::overview/apoc.text/apoc.text.snakeCase.adoc[apoc.text.snakeCase(text)] | Convert a string to snake-case\n| xref::overview/apoc.text/apoc.text.toUpperCase.adoc[apoc.text.toUpperCase(text)] | Convert a string to UPPER_CASE\n| xref::overview/apoc.text/apoc.text.charAt.adoc[apoc.text.charAt(text, index)] | Returns the decimal value of the character at the given index\n| xref::overview/apoc.text/apoc.text.code.adoc[apoc.text.code(codepoint)] | Returns the unicode character of the given codepoint\n| xref::overview/apoc.text/apoc.text.hexCharAt.adoc[apoc.text.hexCharAt(text, index)] | Returns the hex value string of the character at the given index\n| xref::overview/apoc.text/apoc.text.hexValue.adoc[apoc.text.hexValue(value)] | Returns the hex value string of the given value\n| xref::overview/apoc.text/apoc.text.byteCount.adoc[+++apoc.text.byteCount(text,[charset])+++] | return size of text in bytes\n| xref::overview/apoc.text/apoc.text.bytes.adoc[+++apoc.text.bytes(text,[charset])+++] | return bytes of the text\n| xref::overview/apoc.text/apoc.text.toCypher.adoc[apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end})] | tries its best to convert the value to a cypher-property-string\n| xref::overview/apoc.text/apoc.text.base64Encode.adoc[apoc.text.base64Encode(text)] | Encode a string with Base64\n| xref::overview/apoc.text/apoc.text.base64Decode.adoc[apoc.text.base64Decode(text)] | Decode Base64 encoded string\n| xref::overview/apoc.text/apoc.text.base64UrlEncode.adoc[apoc.text.base64UrlEncode(url)] | Encode a url with Base64\n| xref::overview/apoc.text/apoc.text.base64UrlDecode.adoc[apoc.text.base64UrlDecode(url)] | Decode Base64 encoded url\n|\u003d\u003d\u003d\n\nThe `replace`, `split` and `regexGroups` functions work with regular expressions.\n\n\n[[text-functions-data-extraction]]\n\u003d\u003d Data Extraction\n\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.data.url(\u0027url\u0027) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\n| apoc.data.email(\u0027email_address\u0027) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\n| apoc.data.domain(email_or_url) | *deprecated* returns domain part of the value\n|\u003d\u003d\u003d\n\n[[text-functions-text-similarity]]\n\u003d\u003d Text Similarity Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u003c 3 then 0, length \u003c 5 then 1, else 2).\n|\u003d\u003d\u003d\nThe replace, split and regexGroups functions work with regular expressions.\n\n\n\n\n\u003d\u003d Data extraction\n\n\n\n\u003d\u003d Text Similarity\n\n// useful to data clean purpose\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u003c 3 then 0, length \u003c 5 then 1, else 2).\n|\u003d\u003d\u003d\n\n\n.will return \u0027HelloWorld\u0027\n[source,cypher]\n----\nRETURN apoc.text.replace(\u0027Hello World!\u0027, \u0027[^a-zA-Z]\u0027, \u0027\u0027)\n----\n\n[source,cypher]\n----\nRETURN apoc.text.regexGroups(\u0027abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0027,\u0027\u003clink (\\\\w+)\u003e(\\\\w+)\u003c/link\u003e\u0027) AS result\n\n// [[\"\u003clink xxx1\u003eyyy1\u003c/link\u003e\", \"xxx1\", \"yyy1\"], [\"\u003clink xxx2\u003eyyy2\u003c/link\u003e\", \"xxx2\", \"yyy2\"]]\n----\n\n\n\n\u003d\u003d\u003d Compare the  strings with the Levenshtein distance\n\nCompare the given strings with the `StringUtils.distance(text1, text2)` method (Levenshtein).\n\n[source,cypher]\n----\nRETURN apoc.text.distance(\"Levenshtein\", \"Levenstein\") // 1\n----\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.data.url(\u0027url\u0027) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\n| apoc.data.email(\u0027email_address\u0027) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\n| apoc.data.domain(email_or_url) | *deprecated* returns domain part of the value\n|\u003d\u003d\u003d\n\n\n[[text-functions-phonetic-comparison]]\n\u003d\u003d Phonetic Comparison Functions\n\nThe phonetic text (soundex) functions allow you to compute the soundex encoding of a given string.\nThere is also a procedure to compare how similar two strings sound under the soundex algorithm.\nAll soundex procedures by default assume the used language is US English.\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.phonetic(value) | Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings\n| apoc.text.doubleMetaphone(value) | Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings\n| apoc.text.clean(text) | strip the given string of everything except alpha numeric characters and convert it to lower case.\n| apoc.text.compareCleaned(text1, text2) | compare the given strings stripped of everything except alpha numeric characters converted to lower case.\n|\u003d\u003d\u003d\n\n.Procedure\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta | Compute the US_ENGLISH soundex character difference between two given strings\n|\u003d\u003d\u003d\n\n[source,cypher]\n----\n// will return \u0027H436\u0027\nRETURN apoc.text.phonetic(\u0027Hello, dear User!\u0027)\n----\n\n[source,cypher]\n----\n// will return \u00274\u0027  (very similar)\nRETURN apoc.text.phoneticDelta(\u0027Hello Mr Rabbit\u0027, \u0027Hello Mr Ribbit\u0027)\n----\n\n[[text-functions-formatting-text]]\n\u003d\u003d Formatting Text\n\nFormat the string with the params given, and optional param language.\n\n.without language param (\u0027en\u0027 default)\n\n[source,cypher]\n----\nRETURN apoc.text.format(\u0027ab%s %d %.1f %s%n\u0027,[\u0027cd\u0027,42,3.14,true]) AS value // abcd 42 3.1 true\n----\n\n.with language param\n\n[source,cypher]\n----\nRETURN apoc.text.format(\u0027ab%s %d %.1f %s%n\u0027,[\u0027cd\u0027,42,3.14,true],\u0027it\u0027) AS value // abcd 42 3,1 true\n----\n\n[[text-functions-string-search]]\n\u003d\u003d String Search\n\nThe `indexOf` function, provides the fist occurrence of the given `lookup` string within the `text`, or -1 if not found.\nIt can optionally take `from` (inclusive) and `to` (exclusive) parameters.\n\n[source,cypher]\n----\nRETURN apoc.text.indexOf(\u0027Hello World!\u0027, \u0027World\u0027) // 6\n----\n\nThe `indexesOf` function, provides all occurrences of the given lookup string within the text, or empty list if not found.\nIt can optionally take `from` (inclusive) and `to` (exclusive) parameters.\n\n\n[source,cypher]\n----\nRETURN apoc.text.indexesOf(\u0027Hello World!\u0027, \u0027o\u0027,2,9) // [4,7]\n----\n\nIf you want to get a substring starting from your index match, you can use this\n\n.returns `World!`\n[source,cypher]\n----\nWITH \u0027Hello World!\u0027 as text, length(text) as len\nWITH text, len, apoc.text.indexOf(text, \u0027World\u0027,3) as index\nRETURN substring(text, case index when -1 then len-1 else index end, len);\n----\n\n[[text-functions-regex]]\n\u003d\u003d Regular Expressions\n\n.will return \u0027HelloWorld\u0027\n[source,cypher]\n----\nRETURN apoc.text.replace(\u0027Hello World!\u0027, \u0027[^a-zA-Z]\u0027, \u0027\u0027)\n----\n\n[source,cypher]\n----\nRETURN apoc.text.regexGroups(\u0027abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0027,\u0027\u003clink (\\\\w+)\u003e(\\\\w+)\u003c/link\u003e\u0027) AS result\n\n// [[\"\u003clink xxx1\u003eyyy1\u003c/link\u003e\", \"xxx1\", \"yyy1\"], [\"\u003clink xxx2\u003eyyy2\u003c/link\u003e\", \"xxx2\", \"yyy2\"]]\n----\n\n\n[[text-functions-split-join]]\n\u003d\u003d Split and Join\n\n.will split with the given regular expression return [\u0027Hello\u0027, \u0027World\u0027]\n[source,cypher]\n----\nRETURN apoc.text.split(\u0027Hello   World\u0027, \u0027 +\u0027)\n----\n\n.will return \u0027Hello World\u0027\n[source,cypher]\n----\nRETURN apoc.text.join([\u0027Hello\u0027, \u0027World\u0027], \u0027 \u0027)\n----\n\n[[text-functions-data-cleaning]]\n\u003d\u003d Data Cleaning\n\n.will return \u0027helloworld\u0027\n[source,cypher]\n----\nRETURN apoc.text.clean(\u0027Hello World!\u0027)\n----\n\n.will return `true`\n[source,cypher]\n----\nRETURN apoc.text.compareCleaned(\u0027Hello World!\u0027, \u0027_hello-world_\u0027)\n----\n\n.will return only \u0027Hello World!\u0027\n[source,cypher]\n----\nUNWIND [\u0027Hello World!\u0027, \u0027hello worlds\u0027] as text\nRETURN apoc.text.filterCleanMatches(text, \u0027hello_world\u0027) as text\n----\n\nThe clean functionality can be useful for cleaning up slightly dirty text data with inconsistent formatting for non-exact comparisons.\n\nCleaning will strip the string of all non-alphanumeric characters (including spaces) and convert it to lower case.\n\n[[text-functions-case-change]]\n\u003d\u003d Case Change Functions\n\n.Capitalise the first letter of the word with `capitalize`\n[source,cypher]\n----\nRETURN apoc.text.capitalize(\"neo4j\") // \"Neo4j\"\n----\n\n.Capitalise the first letter of every word in the text with `capitalizeAll`\n[source,cypher]\n----\nRETURN apoc.text.capitalizeAll(\"graph database\") // \"Graph Database\"\n----\n\n.Decapitalize the first letter of the string with `decapitalize`\n[source,cypher]\n----\nRETURN apoc.text.decapitalize(\"Graph Database\") // \"graph Database\"\n----\n\n.Decapitalize the first letter of all words with `decapitalizeAll`\n[source,cypher]\n----\nRETURN apoc.text.decapitalizeAll(\"Graph Databases\") // \"graph databases\"\n----\n\n.Swap the case of a string with `swapCase`\n[source,cypher]\n----\nRETURN apoc.text.swapCase(\"Neo4j\") // nEO4J\n----\n\n.Convert a string to lower camelCase with `camelCase`\n[source,cypher]\n----\nRETURN apoc.text.camelCase(\"FOO_BAR\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foo bar\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foo22 bar\");  // \"foo22Bar\"\nRETURN apoc.text.camelCase(\"foo-bar\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foobar\");     // \"foobar\"\nRETURN apoc.text.camelCase(\"Foo$$Bar\");   // \"fooBar\"\n----\n\n.Convert a string to UpperCamelCase with `upperCamelCase`\n[source,cypher]\n----\nRETURN apoc.text.upperCamelCase(\"FOO_BAR\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foo bar\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foo22 bar\"); // \"Foo22Bar\"\nRETURN apoc.text.upperCamelCase(\"foo-bar\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foobar\");    // \"Foobar\"\nRETURN apoc.text.upperCamelCase(\"Foo$$Bar\");  // \"FooBar\"\n----\n\n.Convert a string to snake-case with `snakeCase`\n[source,cypher]\n----\nRETURN apoc.text.snakeCase(\"test Snake Case\"); // \"test-snake-case\"\nRETURN apoc.text.snakeCase(\"FOO_BAR\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"fooBar\");          // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"foo-bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo  bar\");        // \"foo-bar\"\n----\n\n.Convert a string to UPPER_CASE with `toUpperCase`\n[source,cypher]\n----\nRETURN apoc.text.toUpperCase(\"test upper case\"); // \"TEST_UPPER_CASE\"\nRETURN apoc.text.toUpperCase(\"FooBar\");          // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"fooBar\");          // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo-bar\");         // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo--bar\");        // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo$$bar\");        // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo 22 bar\");      // \"FOO_22_BAR\"\n----\n\n\n[[text-functions-base64-encoding-decoding]]\n\u003d\u003d Base64 De- and Encoding\n\nEncode or decode a string in base64 or base64Url\n\n.Encode base 64\n[source,cypher]\n----\nRETURN apoc.text.base64Encode(\"neo4j\") // bmVvNGo\u003d\n----\n\n.Decode base 64\n[source,cypher]\n----\nRETURN apoc.text.base64Decode(\"bmVvNGo\u003d\") // neo4j\n----\n\n\n.Encode base 64 URL\n[source,cypher]\n----\nRETURN apoc.text.base64UrlEncode(\"http://neo4j.com/?test\u003dtest\") // aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\n----\n\n.Decode base 64 URL\n[source,cypher]\n----\nRETURN apoc.text.base64UrlDecode(\"aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\") // http://neo4j.com/?test\u003dtest\n----\n\n[[text-functions-random-string]]\n\u003d\u003d Random String\n\nYou can generate a random string to a specified length by calling `apoc.text.random` with a length parameter and optional string of valid characters.\n\nThe `valid` parameter will accept the following regex patterns, alternatively you can provide a string of letters and/or characters.\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| Pattern | Description\n| A-Z | A-Z in uppercase\n| a-z | A-Z in lowercase\n| 0-9 | Numbers 0-9 inclusive\n|\u003d\u003d\u003d\n\n.The following call will return a random string including uppercase letters, numbers and `.` and `$` characters.\n[source,cypher]\n----\nRETURN apoc.text.random(10, \"A-Z0-9.$\")\n----\n\n[[text-functions-extract-domain]]\n\u003d\u003d Extract Domain\n\nThe User Function `apoc.data.domain` will take a url or email address and try to determine the domain name.\nThis can be useful to make easier correlations and equality tests between differently formatted email addresses, and between urls to the same domains but specifying different locations.\n\n[source,cypher]\n----\nWITH \u0027foo@bar.com\u0027 AS email\nRETURN apoc.data.domain(email) // will return \u0027bar.com\u0027\n----\n\n[source,cypher]\n----\nWITH \u0027http://www.example.com/all-the-things\u0027 AS url\nRETURN apoc.data.domain(url) // will return \u0027www.example.com\u0027\n----\n\n[[text-functions-hashing]]\n\u003d\u003d Hashing Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list\n| apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list\n|\u003d\u003d\u003d\n\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:45:10.514",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Text function\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/misc/text-functions/\"\u003ehttps://neo4j.com/labs/apoc/4.1/misc/text-functions/\u003c/a\u003e\u003cbr /\u003e\n// there are a bunch of useful text functions\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-overview\"\u003etext-functions-overview\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Overview Text Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.indexOf.adoc[apoc.text.indexOf(text, lookup, offset\u003d0, to\u003d-1\u003d\u003dlen)] | find the first occurence of the lookup string in the text, from inclusive, to exclusive,, -1 if not found, null if text is null.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.indexesOf.adoc[apoc.text.indexesOf(text, lookup, from\u003d0, to\u003d-1\u003d\u003dlen)] | finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.replace.adoc[apoc.text.replace(text, regex, replacement)] | replace each substring of the given string that matches the given regular expression with the given replacement.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.regexGroups.adoc[apoc.text.regexGroups(text, regex)] | returns an array containing a nested array for each match. The inner array contains all match groups.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.join.adoc[+++apoc.text.join([\u0026lsquo;text1\u0026rsquo;,\u0026lsquo;text2\u0026rsquo;,\u0026hellip;], delimiter)+++] | join the given strings with the given delimiter.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.repeat.adoc[apoc.text.repeat(\u0026lsquo;item\u0026rsquo;,count)] | multiply the given string with the given count\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.format.adoc[apoc.text.format(text,[params],language)] | sprintf format the string with the params given, and optional param language (default value is \u0026lsquo;en\u0026rsquo;).\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.lpad.adoc[apoc.text.lpad(text,count,delim)] | left pad the string to the given width\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.rpad.adoc[apoc.text.rpad(text,count,delim)] | right pad the string to the given width\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.random.adoc[apoc.text.random(length, [valid])] | returns a random string to the specified length\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.capitalize.adoc[apoc.text.capitalize(text)] | capitalise the first letter of the word\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.capitalizeAll.adoc[apoc.text.capitalizeAll(text)] | capitalise the first letter of every word in the text\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.decapitalize.adoc[apoc.text.decapitalize(text)] | decapitalize the first letter of the word\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.decapitalizeAll.adoc[apoc.text.decapitalizeAll(text)] | decapitalize the first letter of all words\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.swapCase.adoc[apoc.text.swapCase(text)] | Swap the case of a string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.camelCase.adoc[apoc.text.camelCase(text)] | Convert a string to camelCase\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.upperCamelCase.adoc[apoc.text.upperCamelCase(text)] | Convert a string to UpperCamelCase\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.snakeCase.adoc[apoc.text.snakeCase(text)] | Convert a string to snake-case\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.toUpperCase.adoc[apoc.text.toUpperCase(text)] | Convert a string to UPPER_CASE\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.charAt.adoc[apoc.text.charAt(text, index)] | Returns the decimal value of the character at the given index\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.code.adoc[apoc.text.code(codepoint)] | Returns the unicode character of the given codepoint\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.hexCharAt.adoc[apoc.text.hexCharAt(text, index)] | Returns the hex value string of the character at the given index\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.hexValue.adoc[apoc.text.hexValue(value)] | Returns the hex value string of the given value\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.byteCount.adoc[+++apoc.text.byteCount(text,[charset])+++] | return size of text in bytes\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.bytes.adoc[+++apoc.text.bytes(text,[charset])+++] | return bytes of the text\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.toCypher.adoc[apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end})] | tries its best to convert the value to a cypher-property-string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64Encode.adoc[apoc.text.base64Encode(text)] | Encode a string with Base64\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64Decode.adoc[apoc.text.base64Decode(text)] | Decode Base64 encoded string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64UrlEncode.adoc[apoc.text.base64UrlEncode(url)] | Encode a url with Base64\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64UrlDecode.adoc[apoc.text.base64UrlDecode(url)] | Decode Base64 encoded url\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ereplace\u003c/code\u003e, \u003ccode\u003esplit\u003c/code\u003e and \u003ccode\u003eregexGroups\u003c/code\u003e functions work with regular expressions.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-data-extraction\"\u003etext-functions-data-extraction\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Data Extraction\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.data.url(\u0026lsquo;url\u0026rsquo;) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\u003cbr /\u003e\n| apoc.data.email(\u0026lsquo;email_address\u0026rsquo;) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\u003cbr /\u003e\n| apoc.data.domain(email_or_url) | \u003cem\u003edeprecated\u003c/em\u003e returns domain part of the value\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-text-similarity\"\u003etext-functions-text-similarity\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Text Similarity Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\u003cbr /\u003e\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\u003cbr /\u003e\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\u003cbr /\u003e\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u0026lt; 3 then 0, length \u0026lt; 5 then 1, else 2).\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\nThe replace, split and regexGroups functions work with regular expressions.\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Data extraction\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Text Similarity\u003c/p\u003e\n\u003cp\u003e// useful to data clean purpose\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\u003cbr /\u003e\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\u003cbr /\u003e\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\u003cbr /\u003e\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u0026lt; 3 then 0, length \u0026lt; 5 then 1, else 2).\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;HelloWorld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.replace(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;[^a-zA-Z]\u0026rsquo;, \u0027\u0027)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eRETURN apoc.text.regexGroups(\u0026lsquo;abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rsquo;,\u0026lsquo;\u0026lt;link (\\w+)\u0026gt;(\\w+)\u003c/link\u003e\u0026rsquo;) AS result\u003c/p\u003e\n\u003ch2\u003e// [[\u0026ldquo;\u003clink xxx1\u003eyyy1\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx1\u0026rdquo;, \u0026ldquo;yyy1\u0026rdquo;], [\u0026ldquo;\u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx2\u0026rdquo;, \u0026ldquo;yyy2\u0026rdquo;]]\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d\u003d Compare the  strings with the Levenshtein distance\u003c/p\u003e\n\u003cp\u003eCompare the given strings with the \u003ccode\u003eStringUtils.distance(text1, text2)\u003c/code\u003e method (Levenshtein).\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.distance(\u0026ldquo;Levenshtein\u0026rdquo;, \u0026ldquo;Levenstein\u0026rdquo;) // 1\u003c/h2\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.data.url(\u0026lsquo;url\u0026rsquo;) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\u003cbr /\u003e\n| apoc.data.email(\u0026lsquo;email_address\u0026rsquo;) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\u003cbr /\u003e\n| apoc.data.domain(email_or_url) | \u003cem\u003edeprecated\u003c/em\u003e returns domain part of the value\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-phonetic-comparison\"\u003etext-functions-phonetic-comparison\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Phonetic Comparison Functions\u003c/p\u003e\n\u003cp\u003eThe phonetic text (soundex) functions allow you to compute the soundex encoding of a given string.\u003cbr /\u003e\nThere is also a procedure to compare how similar two strings sound under the soundex algorithm.\u003cbr /\u003e\nAll soundex procedures by default assume the used language is US English.\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.phonetic(value) | Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings\u003cbr /\u003e\n| apoc.text.doubleMetaphone(value) | Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings\u003cbr /\u003e\n| apoc.text.clean(text) | strip the given string of everything except alpha numeric characters and convert it to lower case.\u003cbr /\u003e\n| apoc.text.compareCleaned(text1, text2) | compare the given strings stripped of everything except alpha numeric characters converted to lower case.\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e.Procedure\u003cbr /\u003e\n[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta | Compute the US_ENGLISH soundex character difference between two given strings\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003e// will return \u0026lsquo;H436\u0026rsquo;\u003cbr /\u003e\nRETURN apoc.text.phonetic(\u0026lsquo;Hello, dear User!\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003e// will return \u0026lsquo;4\u0026rsquo;  (very similar)\u003cbr /\u003e\nRETURN apoc.text.phoneticDelta(\u0026lsquo;Hello Mr Rabbit\u0026rsquo;, \u0026lsquo;Hello Mr Ribbit\u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-formatting-text\"\u003etext-functions-formatting-text\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Formatting Text\u003c/p\u003e\n\u003cp\u003eFormat the string with the params given, and optional param language.\u003c/p\u003e\n\u003cp\u003e.without language param (\u0026lsquo;en\u0026rsquo; default)\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.format(\u0026lsquo;ab%s %d %.1f %s%n\u0026rsquo;,[\u0026lsquo;cd\u0026rsquo;,42,3.14,true]) AS value // abcd 42 3.1 true\u003c/h2\u003e\n\u003cp\u003e.with language param\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.format(\u0026lsquo;ab%s %d %.1f %s%n\u0026rsquo;,[\u0026lsquo;cd\u0026rsquo;,42,3.14,true],\u0026lsquo;it\u0026rsquo;) AS value // abcd 42 3,1 true\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-string-search\"\u003etext-functions-string-search\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d String Search\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eindexOf\u003c/code\u003e function, provides the fist occurrence of the given \u003ccode\u003elookup\u003c/code\u003e string within the \u003ccode\u003etext\u003c/code\u003e, or -1 if not found.\u003cbr /\u003e\nIt can optionally take \u003ccode\u003efrom\u003c/code\u003e (inclusive) and \u003ccode\u003eto\u003c/code\u003e (exclusive) parameters.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.indexOf(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;World\u0026rsquo;) // 6\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eindexesOf\u003c/code\u003e function, provides all occurrences of the given lookup string within the text, or empty list if not found.\u003cbr /\u003e\nIt can optionally take \u003ccode\u003efrom\u003c/code\u003e (inclusive) and \u003ccode\u003eto\u003c/code\u003e (exclusive) parameters.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.indexesOf(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;o\u0026rsquo;,2,9) // [4,7]\u003c/h2\u003e\n\u003cp\u003eIf you want to get a substring starting from your index match, you can use this\u003c/p\u003e\n\u003ch2\u003e.returns \u003ccode\u003eWorld!\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;Hello World!\u0026rsquo; as text, length(text) as len\u003cbr /\u003e\nWITH text, len, apoc.text.indexOf(text, \u0026lsquo;World\u0026rsquo;,3) as index\u003cbr /\u003e\nRETURN substring(text, case index when -1 then len-1 else index end, len);\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-regex\"\u003etext-functions-regex\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Regular Expressions\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;HelloWorld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.replace(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;[^a-zA-Z]\u0026rsquo;, \u0027\u0027)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eRETURN apoc.text.regexGroups(\u0026lsquo;abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rsquo;,\u0026lsquo;\u0026lt;link (\\w+)\u0026gt;(\\w+)\u003c/link\u003e\u0026rsquo;) AS result\u003c/p\u003e\n\u003ch2\u003e// [[\u0026ldquo;\u003clink xxx1\u003eyyy1\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx1\u0026rdquo;, \u0026ldquo;yyy1\u0026rdquo;], [\u0026ldquo;\u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx2\u0026rdquo;, \u0026ldquo;yyy2\u0026rdquo;]]\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-split-join\"\u003etext-functions-split-join\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Split and Join\u003c/p\u003e\n\u003ch2\u003e.will split with the given regular expression return [\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;World\u0026rsquo;]\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.split(\u0026lsquo;Hello   World\u0026rsquo;, \u0026rsquo; +\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return \u0026lsquo;Hello World\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.join([\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;World\u0026rsquo;], \u0026rsquo; \u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-data-cleaning\"\u003etext-functions-data-cleaning\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Data Cleaning\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;helloworld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.clean(\u0026lsquo;Hello World!\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return \u003ccode\u003etrue\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.compareCleaned(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;\u003cem\u003ehello-world\u003c/em\u003e\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return only \u0026lsquo;Hello World!\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eUNWIND [\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;hello worlds\u0026rsquo;] as text\u003cbr /\u003e\nRETURN apoc.text.filterCleanMatches(text, \u0026lsquo;hello_world\u0026rsquo;) as text\u003c/h2\u003e\n\u003cp\u003eThe clean functionality can be useful for cleaning up slightly dirty text data with inconsistent formatting for non-exact comparisons.\u003c/p\u003e\n\u003cp\u003eCleaning will strip the string of all non-alphanumeric characters (including spaces) and convert it to lower case.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-case-change\"\u003etext-functions-case-change\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Case Change Functions\u003c/p\u003e\n\u003ch2\u003e.Capitalise the first letter of the word with \u003ccode\u003ecapitalize\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.capitalize(\u0026ldquo;neo4j\u0026rdquo;) // \u0026ldquo;Neo4j\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Capitalise the first letter of every word in the text with \u003ccode\u003ecapitalizeAll\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.capitalizeAll(\u0026ldquo;graph database\u0026rdquo;) // \u0026ldquo;Graph Database\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Decapitalize the first letter of the string with \u003ccode\u003edecapitalize\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.decapitalize(\u0026ldquo;Graph Database\u0026rdquo;) // \u0026ldquo;graph Database\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Decapitalize the first letter of all words with \u003ccode\u003edecapitalizeAll\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.decapitalizeAll(\u0026ldquo;Graph Databases\u0026rdquo;) // \u0026ldquo;graph databases\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Swap the case of a string with \u003ccode\u003eswapCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.swapCase(\u0026ldquo;Neo4j\u0026rdquo;) // nEO4J\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to lower camelCase with \u003ccode\u003ecamelCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.camelCase(\u0026ldquo;FOO_BAR\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo bar\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo22 bar\u0026rdquo;);  // \u0026ldquo;foo22Bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;foo-bar\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foobar\u0026rdquo;);     // \u0026ldquo;foobar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo$$Bar\u0026rdquo;);   // \u0026ldquo;fooBar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to UpperCamelCase with \u003ccode\u003eupperCamelCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.upperCamelCase(\u0026ldquo;FOO_BAR\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo bar\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo22 bar\u0026rdquo;); // \u0026ldquo;Foo22Bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;foo-bar\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foobar\u0026rdquo;);    // \u0026ldquo;Foobar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo$$Bar\u0026rdquo;);  // \u0026ldquo;FooBar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to snake-case with \u003ccode\u003esnakeCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.snakeCase(\u0026ldquo;test Snake Case\u0026rdquo;); // \u0026ldquo;test-snake-case\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;FOO_BAR\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;fooBar\u0026rdquo;);          // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;foo-bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo  bar\u0026rdquo;);        // \u0026ldquo;foo-bar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to UPPER_CASE with \u003ccode\u003etoUpperCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.toUpperCase(\u0026ldquo;test upper case\u0026rdquo;); // \u0026ldquo;TEST_UPPER_CASE\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;FooBar\u0026rdquo;);          // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;fooBar\u0026rdquo;);          // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo-bar\u0026rdquo;);         // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo\u0026ndash;bar\u0026rdquo;);        // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo$$bar\u0026rdquo;);        // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo 22 bar\u0026rdquo;);      // \u0026ldquo;FOO_22_BAR\u0026rdquo;\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-base64-encoding-decoding\"\u003etext-functions-base64-encoding-decoding\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Base64 De- and Encoding\u003c/p\u003e\n\u003cp\u003eEncode or decode a string in base64 or base64Url\u003c/p\u003e\n\u003ch2\u003e.Encode base 64\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64Encode(\u0026ldquo;neo4j\u0026rdquo;) // bmVvNGo\u003d\u003c/h2\u003e\n\u003ch2\u003e.Decode base 64\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64Decode(\u0026ldquo;bmVvNGo\u003d\u0026rdquo;) // neo4j\u003c/h2\u003e\n\u003ch2\u003e.Encode base 64 URL\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64UrlEncode(\u0026ldquo;\u003ca href\u003d\"http://neo4j.com/?test\u003dtest\"\u003ehttp://neo4j.com/?test\u003dtest\u003c/a\u003e\u0026rdquo;) // aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\u003c/h2\u003e\n\u003ch2\u003e.Decode base 64 URL\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64UrlDecode(\u0026ldquo;aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\u0026rdquo;) // \u003ca href\u003d\"http://neo4j.com/?test\u003dtest\"\u003ehttp://neo4j.com/?test\u003dtest\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-random-string\"\u003etext-functions-random-string\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Random String\u003c/p\u003e\n\u003cp\u003eYou can generate a random string to a specified length by calling \u003ccode\u003eapoc.text.random\u003c/code\u003e with a length parameter and optional string of valid characters.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003evalid\u003c/code\u003e parameter will accept the following regex patterns, alternatively you can provide a string of letters and/or characters.\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| Pattern | Description\u003cbr /\u003e\n| A-Z | A-Z in uppercase\u003cbr /\u003e\n| a-z | A-Z in lowercase\u003cbr /\u003e\n| 0-9 | Numbers 0-9 inclusive\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.The following call will return a random string including uppercase letters, numbers and \u003ccode\u003e.\u003c/code\u003e and \u003ccode\u003e$\u003c/code\u003e characters.\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.random(10, \u0026ldquo;A-Z0-9.$\u0026rdquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-extract-domain\"\u003etext-functions-extract-domain\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Extract Domain\u003c/p\u003e\n\u003cp\u003eThe User Function \u003ccode\u003eapoc.data.domain\u003c/code\u003e will take a url or email address and try to determine the domain name.\u003cbr /\u003e\nThis can be useful to make easier correlations and equality tests between differently formatted email addresses, and between urls to the same domains but specifying different locations.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;\u003ca href\u003d\"mailto:foo@bar.com\"\u003efoo@bar.com\u003c/a\u003e\u0026rsquo; AS email\u003cbr /\u003e\nRETURN apoc.data.domain(email) // will return \u0026lsquo;bar.com\u0026rsquo;\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;\u003ca href\u003d\"http://www.example.com/all-the-things\"\u003ehttp://www.example.com/all-the-things\u003c/a\u003e\u0026rsquo; AS url\u003cbr /\u003e\nRETURN apoc.data.domain(url) // will return \u0026lsquo;\u003ca href\u003d\"http://www.example.com\"\u003ewww.example.com\u003c/a\u003e\u0026rsquo;\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-hashing\"\u003etext-functions-hashing\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Hashing Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list\u003cbr /\u003e\n| apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349483128_1944019862",
      "id": "paragraph_1635349483128_1944019862",
      "dateCreated": "2021-10-27 15:44:43.128",
      "dateStarted": "2021-10-27 15:45:10.511",
      "dateFinished": "2021-10-27 15:45:10.726",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d Spatial\n\nThe spatial procedures enable geographic capabilities on your data, and complement the https://neo4j.com/docs/cypher-manual/current/functions/spatial/[spatial functions^] that come with Neo4j.\nMore extensive Spatial functionality can be found in the https://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html[Neo4j Spatial Library^].\n\n[separator\u003d¦,opts\u003dheader,cols\u003d\"5,1m,1m\"]\n|\u003d\u003d\u003d\n¦Qualified Name¦Type¦Release\ninclude::example$generated-documentation/apoc.spatial.geocode.adoc[]\ninclude::example$generated-documentation/apoc.spatial.reverseGeocode.adoc[]\ninclude::example$generated-documentation/apoc.spatial.sortByDistance.adoc[]\n|\u003d\u003d\u003d\n\n\n\u003d\u003d Geocode\n\nThe _geocode_ procedure converts a textual address into a location containing _latitude_, _longitude_ and _description_.\nDespite being only a single function, together with the built-in functions _point_ and _distance_ we can achieve quite powerful results.\n\nFirst, how can we use the procedure:\n\n[source,cypher]\n----\nCALL apoc.spatial.geocodeOnce(\u002721 rue Paul Bellamy 44000 NANTES FRANCE\u0027)\nYIELD location\nRETURN location.latitude, location.longitude\n----\n\n.Results\n[opts\u003d\"header\"]\n|\u003d\u003d\u003d\n| location.latitude | location.longitude\n| 47.2221667 | -1.5566625\n|\u003d\u003d\u003d\n\n\nThere are three forms of the procedure:\n\n* geocodeOnce(address) returns zero or one result.\n* geocode(address,maxResults) returns zero, one or more up to maxResults.\n* reverseGeocode(latitude,longitude) returns zero or one result.\n\nThis is because the backing geocoding service (OSM, Google, OpenCage or other) might return multiple results for the same query.\nGeocodeOnce() is designed to return the first, or highest ranking result.\n\nThe third procedure _reverseGeocode_ will convert a location containing _latitude_ and _longitude_ into a textual address.\n\n[source,cypher]\n----\nCALL apoc.spatial.reverseGeocode(47.2221667,-1.5566625) YIELD location\nRETURN location.description;\n----\n\n.Results\n[opts\u003d\"header\"]\n|\u003d\u003d\u003d\n| location.description\n| \"21, Rue Paul Bellamy, Talensac - Pont Morand, Hauts-Pavés - Saint-Félix, Nantes, Loire-Atlantique, Pays de la Loire, France métropolitaine, 44000, France\"\n|\u003d\u003d\u003d\n\n\u003d\u003d\u003d Configuring Geocode\n\nThere are a few options that can be set in the apoc.conf file to control the service:\n\n* apoc.spatial.geocode.provider\u003dosm (osm, google, opencage, etc.)\n* apoc.spatial.geocode.osm.throttle\u003d5000 (ms to delay between queries to not overload OSM servers)\n* apoc.spatial.geocode.google.throttle\u003d1 (ms to delay between queries to not overload Google servers)\n* apoc.spatial.geocode.google.key\u003dxxxx (API key for google geocode access)\n* apoc.spatial.geocode.google.client\u003dxxxx (client code for google geocode access)\n* apoc.spatial.geocode.google.signature\u003dxxxx (client signature for google geocode access)\n\nFor google, you should use either a key or a combination of client and signature. Read more\nabout this on the google page for geocode access at\nhttps://developers.google.com/maps/documentation/geocoding/get-api-key#key\n\n\u003d\u003d\u003d Configuring Custom Geocode Provider\n\n*Geocode*\n\nFor any provider that is not \u0027osm\u0027 or \u0027google\u0027 you get a configurable supplier that requires two\nadditional settings, \u0027url\u0027 and \u0027key\u0027. The \u0027url\u0027 must contain the two words \u0027PLACE\u0027 and \u0027KEY\u0027.\nThe \u0027KEY\u0027 will be replaced with the key you get from the provider when you register for the service.\nThe \u0027PLACE\u0027 will be replaced with the address to geocode when the procedure is called.\n\n*Reverse Geocode*\n\nThe \u0027url\u0027 must contain the three words \u0027LAT\u0027, \u0027LNG\u0027 and \u0027KEY\u0027.\nThe \u0027LAT\u0027 will be replaced with the latitude and \u0027LNG\u0027 will be replaced with the the longitude to reverse geocode when the procedure is called.\n\nFor example, to get the service working with OpenCage, perform the following steps:\n\n* Register your own application key at https://geocoder.opencagedata.com/\n* Once you have a key, add the following three lines to apoc.conf\n\n----\napoc.spatial.geocode.provider\u003dopencage\napoc.spatial.geocode.opencage.key\u003dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\napoc.spatial.geocode.opencage.url\u003dhttp://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026key\u003dKEY\napoc.spatial.geocode.opencage.reverse.url\u003dhttp://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026key\u003dKEY\n----\n\n* make sure that the \u0027XXXXXXX\u0027 part above is replaced with your actual key\n* Restart the Neo4j server and then test the geocode procedures to see that they work\n* If you are unsure if the provider is correctly configured try verify with:\n\n\n\n[source,cypher]\n----\nCALL apoc.spatial.showConfig()\n----\n\n\u003d\u003d Using Geocode within a bigger Cypher query\n\nA more complex, or useful, example which geocodes addresses found in properties of nodes:\n\n[source,cypher]\n----\nMATCH (a:Place)\nWHERE exists(a.address)\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nRETURN location.latitude AS latitude, location.longitude AS longitude, location.description AS description\n----\n\n\u003d\u003d Calculating distance between locations\n\nIf we wish to calculate the distance between addresses, we need to use the point() function to convert\nlatitude and longitude to Cyper Point types, and then use the distance() function to calculate the distance:\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (a:Place)\nWHERE exists(a.address)\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nWITH location, distance(point(location), eiffel) AS distance\nWHERE distance \u003c 5000\nRETURN location.description AS description, distance\nORDER BY distance\nLIMIT 100\n----\n\n\u003d\u003d\u003d sortByDistance\n\nThe second procedure enables you to sort a given collection of paths by the sum of their distance based on lat/long properties\non the nodes.\n\nSample data :\n\n[source, cypher]\n----\nCREATE (bruges:City {name:\"bruges\", latitude: 51.2605829, longitude: 3.0817189})\nCREATE (brussels:City {name:\"brussels\", latitude: 50.854954, longitude: 4.3051786})\nCREATE (paris:City {name:\"paris\", latitude: 48.8588376, longitude: 2.2773455})\nCREATE (dresden:City {name:\"dresden\", latitude: 51.0767496, longitude: 13.6321595})\nMERGE (bruges)-[:NEXT]-\u003e(brussels)\nMERGE (brussels)-[:NEXT]-\u003e(dresden)\nMERGE (brussels)-[:NEXT]-\u003e(paris)\nMERGE (bruges)-[:NEXT]-\u003e(paris)\nMERGE (paris)-[:NEXT]-\u003e(dresden)\n----\n\nFinding paths and sort them by distance\n\n[source, cypher]\n----\nMATCH (a:City {name:\u0027bruges\u0027}), (b:City {name:\u0027dresden\u0027})\nMATCH p\u003d(a)-[*]-\u003e(b)\nWITH collect(p) as paths\nCALL apoc.spatial.sortByDistance(paths) YIELD path, distance\nRETURN path, distance\n----\n\n\u003d\u003d Graph Refactoring\n\nIn order not to have to repeatedly geocode the same thing in multiple queries, especially\nif the database will be used by many people, it might be a good idea to persist the results\nin the database so that subsequent calls can use the saved results.\n\nGeocode and persist the result\n\n[source,cypher]\n----\nMATCH (a:Place)\nWHERE exists(a.address) AND NOT exists(a.latitude)\nWITH a LIMIT 1000\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nSET a.latitude \u003d location.latitude\nSET a.longitude \u003d location.longitude\n----\n\nNote that the above command only geocodes the first 1000 ‘Place’ nodes that have not already been geocoded.\nThis query can be run multiple times until all places are geocoded. Why would we want to do this?\nTwo good reasons:\n\n* The geocoding service is a public service that can throttle or blacklist sites that hit the service too heavily, so controlling how much we do is useful.\n* The transaction is updating the database, and it is wise not to update the database with too many things in the same transaction, to avoid using up too much memory. This trick will keep the memory usage very low.\n\nNow make use of the results in distance queries\n\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (a:Place)\nWHERE exists(a.latitude) AND exists(a.longitude)\nWITH a, distance(point(a), eiffel) AS distance\nWHERE distance \u003c 5000\nRETURN a.name, distance\nORDER BY distance\nLIMIT 100\n----\n\n\u003d\u003d Combined Space and Time search\n\nCombining spatial and date-time functions can allow for more complex queries:\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (e:Event)\nWHERE exists(e.address) AND exists(e.datetime)\nCALL apoc.spatial.geocodeOnce(e.address) YIELD location\nWITH e, location,\ndistance(point(location), eiffel) AS distance,\n            (apoc.date.parse(\u00272016-06-01 00:00:00\u0027,\u0027h\u0027) - apoc.date.parse(e.datetime,\u0027h\u0027))/24.0 AS days_before_due\nWHERE distance \u003c 5000 AND days_before_due \u003c 14 AND apoc.date.parse(e.datetime,\u0027h\u0027) \u003c apoc.date.parse(\u00272016-06-01 00:00:00\u0027,\u0027h\u0027)\nRETURN e.name AS event, e.datetime AS date,\nlocation.description AS description, distance\nORDER BY distance\n----\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:46:32.495",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Spatial\u003c/p\u003e\n\u003cp\u003eThe spatial procedures enable geographic capabilities on your data, and complement the \u003ca href\u003d\"https://neo4j.com/docs/cypher-manual/current/functions/spatial/\"\u003ehttps://neo4j.com/docs/cypher-manual/current/functions/spatial/\u003c/a\u003e[spatial functions^] that come with Neo4j.\u003cbr /\u003e\nMore extensive Spatial functionality can be found in the \u003ca href\u003d\"https://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html\"\u003ehttps://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html\u003c/a\u003e[Neo4j Spatial Library^].\u003c/p\u003e\n\u003cp\u003e[separator\u003d¦,opts\u003dheader,cols\u003d\u0026ldquo;5,1m,1m\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n¦Qualified Name¦Type¦Release\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.geocode.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.reverseGeocode.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.sortByDistance.adoc[]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Geocode\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003egeocode\u003c/em\u003e procedure converts a textual address into a location containing \u003cem\u003elatitude\u003c/em\u003e, \u003cem\u003elongitude\u003c/em\u003e and \u003cem\u003edescription\u003c/em\u003e.\u003cbr /\u003e\nDespite being only a single function, together with the built-in functions \u003cem\u003epoint\u003c/em\u003e and \u003cem\u003edistance\u003c/em\u003e we can achieve quite powerful results.\u003c/p\u003e\n\u003cp\u003eFirst, how can we use the procedure:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.geocodeOnce(\u0026lsquo;21 rue Paul Bellamy 44000 NANTES FRANCE\u0026rsquo;)\u003cbr /\u003e\nYIELD location\u003cbr /\u003e\nRETURN location.latitude, location.longitude\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| location.latitude | location.longitude\u003cbr /\u003e\n| 47.2221667 | -1.5566625\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThere are three forms of the procedure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egeocodeOnce(address) returns zero or one result.\u003c/li\u003e\n\u003cli\u003egeocode(address,maxResults) returns zero, one or more up to maxResults.\u003c/li\u003e\n\u003cli\u003ereverseGeocode(latitude,longitude) returns zero or one result.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is because the backing geocoding service (OSM, Google, OpenCage or other) might return multiple results for the same query.\u003cbr /\u003e\nGeocodeOnce() is designed to return the first, or highest ranking result.\u003c/p\u003e\n\u003cp\u003eThe third procedure \u003cem\u003ereverseGeocode\u003c/em\u003e will convert a location containing \u003cem\u003elatitude\u003c/em\u003e and \u003cem\u003elongitude\u003c/em\u003e into a textual address.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.reverseGeocode(47.2221667,-1.5566625) YIELD location\u003cbr /\u003e\nRETURN location.description;\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| location.description\u003cbr /\u003e\n| \u0026ldquo;21, Rue Paul Bellamy, Talensac - Pont Morand, Hauts-Pavés - Saint-Félix, Nantes, Loire-Atlantique, Pays de la Loire, France métropolitaine, 44000, France\u0026rdquo;\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Configuring Geocode\u003c/p\u003e\n\u003cp\u003eThere are a few options that can be set in the apoc.conf file to control the service:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eapoc.spatial.geocode.provider\u003dosm (osm, google, opencage, etc.)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.osm.throttle\u003d5000 (ms to delay between queries to not overload OSM servers)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.throttle\u003d1 (ms to delay between queries to not overload Google servers)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.key\u003dxxxx (API key for google geocode access)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.client\u003dxxxx (client code for google geocode access)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.signature\u003dxxxx (client signature for google geocode access)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor google, you should use either a key or a combination of client and signature. Read more\u003cbr /\u003e\nabout this on the google page for geocode access at\u003cbr /\u003e\n\u003ca href\u003d\"https://developers.google.com/maps/documentation/geocoding/get-api-key#key\"\u003ehttps://developers.google.com/maps/documentation/geocoding/get-api-key#key\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Configuring Custom Geocode Provider\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGeocode\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor any provider that is not \u0026lsquo;osm\u0026rsquo; or \u0026lsquo;google\u0026rsquo; you get a configurable supplier that requires two\u003cbr /\u003e\nadditional settings, \u0026lsquo;url\u0026rsquo; and \u0026lsquo;key\u0026rsquo;. The \u0026lsquo;url\u0026rsquo; must contain the two words \u0026lsquo;PLACE\u0026rsquo; and \u0026lsquo;KEY\u0026rsquo;.\u003cbr /\u003e\nThe \u0026lsquo;KEY\u0026rsquo; will be replaced with the key you get from the provider when you register for the service.\u003cbr /\u003e\nThe \u0026lsquo;PLACE\u0026rsquo; will be replaced with the address to geocode when the procedure is called.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eReverse Geocode\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe \u0026lsquo;url\u0026rsquo; must contain the three words \u0026lsquo;LAT\u0026rsquo;, \u0026lsquo;LNG\u0026rsquo; and \u0026lsquo;KEY\u0026rsquo;.\u003cbr /\u003e\nThe \u0026lsquo;LAT\u0026rsquo; will be replaced with the latitude and \u0026lsquo;LNG\u0026rsquo; will be replaced with the the longitude to reverse geocode when the procedure is called.\u003c/p\u003e\n\u003cp\u003eFor example, to get the service working with OpenCage, perform the following steps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRegister your own application key at \u003ca href\u003d\"https://geocoder.opencagedata.com/\"\u003ehttps://geocoder.opencagedata.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eOnce you have a key, add the following three lines to apoc.conf\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr /\u003e\n\u003ch2\u003eapoc.spatial.geocode.provider\u003dopencage\u003cbr /\u003e\napoc.spatial.geocode.opencage.key\u003dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\u003cbr /\u003e\napoc.spatial.geocode.opencage.url\u003d\u003ca href\u003d\"http://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026amp;key\u003dKEY\"\u003ehttp://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026amp;key\u003dKEY\u003c/a\u003e\u003cbr /\u003e\napoc.spatial.geocode.opencage.reverse.url\u003d\u003ca href\u003d\"http://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026amp;key\u003dKEY\"\u003ehttp://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026amp;key\u003dKEY\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emake sure that the \u0026lsquo;XXXXXXX\u0026rsquo; part above is replaced with your actual key\u003c/li\u003e\n\u003cli\u003eRestart the Neo4j server and then test the geocode procedures to see that they work\u003c/li\u003e\n\u003cli\u003eIf you are unsure if the provider is correctly configured try verify with:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.showConfig()\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Using Geocode within a bigger Cypher query\u003c/p\u003e\n\u003cp\u003eA more complex, or useful, example which geocodes addresses found in properties of nodes:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nRETURN location.latitude AS latitude, location.longitude AS longitude, location.description AS description\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Calculating distance between locations\u003c/p\u003e\n\u003cp\u003eIf we wish to calculate the distance between addresses, we need to use the point() function to convert\u003cbr /\u003e\nlatitude and longitude to Cyper Point types, and then use the distance() function to calculate the distance:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nWITH location, distance(point(location), eiffel) AS distance\u003cbr /\u003e\nWHERE distance \u0026lt; 5000\u003cbr /\u003e\nRETURN location.description AS description, distance\u003cbr /\u003e\nORDER BY distance\u003cbr /\u003e\nLIMIT 100\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d\u003d sortByDistance\u003c/p\u003e\n\u003cp\u003eThe second procedure enables you to sort a given collection of paths by the sum of their distance based on lat/long properties\u003cbr /\u003e\non the nodes.\u003c/p\u003e\n\u003cp\u003eSample data :\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCREATE (bruges:City {name:\u0026ldquo;bruges\u0026rdquo;, latitude: 51.2605829, longitude: 3.0817189})\u003cbr /\u003e\nCREATE (brussels:City {name:\u0026ldquo;brussels\u0026rdquo;, latitude: 50.854954, longitude: 4.3051786})\u003cbr /\u003e\nCREATE (paris:City {name:\u0026ldquo;paris\u0026rdquo;, latitude: 48.8588376, longitude: 2.2773455})\u003cbr /\u003e\nCREATE (dresden:City {name:\u0026ldquo;dresden\u0026rdquo;, latitude: 51.0767496, longitude: 13.6321595})\u003cbr /\u003e\nMERGE (bruges)-[:NEXT]-\u0026gt;(brussels)\u003cbr /\u003e\nMERGE (brussels)-[:NEXT]-\u0026gt;(dresden)\u003cbr /\u003e\nMERGE (brussels)-[:NEXT]-\u0026gt;(paris)\u003cbr /\u003e\nMERGE (bruges)-[:NEXT]-\u0026gt;(paris)\u003cbr /\u003e\nMERGE (paris)-[:NEXT]-\u0026gt;(dresden)\u003c/h2\u003e\n\u003cp\u003eFinding paths and sort them by distance\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:City {name:\u0026lsquo;bruges\u0026rsquo;}), (b:City {name:\u0026lsquo;dresden\u0026rsquo;})\u003cbr /\u003e\nMATCH p\u003d(a)-[*]-\u0026gt;(b)\u003cbr /\u003e\nWITH collect(p) as paths\u003cbr /\u003e\nCALL apoc.spatial.sortByDistance(paths) YIELD path, distance\u003cbr /\u003e\nRETURN path, distance\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Graph Refactoring\u003c/p\u003e\n\u003cp\u003eIn order not to have to repeatedly geocode the same thing in multiple queries, especially\u003cbr /\u003e\nif the database will be used by many people, it might be a good idea to persist the results\u003cbr /\u003e\nin the database so that subsequent calls can use the saved results.\u003c/p\u003e\n\u003cp\u003eGeocode and persist the result\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address) AND NOT exists(a.latitude)\u003cbr /\u003e\nWITH a LIMIT 1000\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nSET a.latitude \u003d location.latitude\u003cbr /\u003e\nSET a.longitude \u003d location.longitude\u003c/h2\u003e\n\u003cp\u003eNote that the above command only geocodes the first 1000 ‘Place’ nodes that have not already been geocoded.\u003cbr /\u003e\nThis query can be run multiple times until all places are geocoded. Why would we want to do this?\u003cbr /\u003e\nTwo good reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe geocoding service is a public service that can throttle or blacklist sites that hit the service too heavily, so controlling how much we do is useful.\u003c/li\u003e\n\u003cli\u003eThe transaction is updating the database, and it is wise not to update the database with too many things in the same transaction, to avoid using up too much memory. This trick will keep the memory usage very low.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow make use of the results in distance queries\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.latitude) AND exists(a.longitude)\u003cbr /\u003e\nWITH a, distance(point(a), eiffel) AS distance\u003cbr /\u003e\nWHERE distance \u0026lt; 5000\u003cbr /\u003e\nRETURN a.name, distance\u003cbr /\u003e\nORDER BY distance\u003cbr /\u003e\nLIMIT 100\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Combined Space and Time search\u003c/p\u003e\n\u003cp\u003eCombining spatial and date-time functions can allow for more complex queries:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (e:Event)\u003cbr /\u003e\nWHERE exists(e.address) AND exists(e.datetime)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(e.address) YIELD location\u003cbr /\u003e\nWITH e, location,\u003cbr /\u003e\ndistance(point(location), eiffel) AS distance,\u003cbr /\u003e\n(apoc.date.parse(\u0026lsquo;2016-06-01 00:00:00\u0026rsquo;,\u0026lsquo;h\u0026rsquo;) - apoc.date.parse(e.datetime,\u0026lsquo;h\u0026rsquo;))/24.0 AS days_before_due\u003cbr /\u003e\nWHERE distance \u0026lt; 5000 AND days_before_due \u0026lt; 14 AND apoc.date.parse(e.datetime,\u0026lsquo;h\u0026rsquo;) \u0026lt; apoc.date.parse(\u0026lsquo;2016-06-01 00:00:00\u0026rsquo;,\u0026lsquo;h\u0026rsquo;)\u003cbr /\u003e\nRETURN e.name AS event, e.datetime AS date,\u003cbr /\u003e\nlocation.description AS description, distance\u003cbr /\u003e\nORDER BY distance\u003c/h2\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349510510_26604918",
      "id": "paragraph_1635349510510_26604918",
      "dateCreated": "2021-10-27 15:45:10.510",
      "dateStarted": "2021-10-27 15:46:32.487",
      "dateFinished": "2021-10-27 15:46:32.562",
      "status": "FINISHED"
    },
    {
      "text": "%md\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:46:32.486",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349592486_1411303387",
      "id": "paragraph_1635349592486_1411303387",
      "dateCreated": "2021-10-27 15:46:32.486",
      "status": "READY"
    }
  ],
  "name": "String, List, Map functions (anche point - lo intitolo [Neo4j primary values functions])",
  "id": "2GN8QQ2U3",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}