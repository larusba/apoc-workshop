{
  "paragraphs": [
    {
      "text": "%md\n\n# REFACTOR DATA in Neo4j with APOC\n\nOne major component of data and business is that it constantly changes. When external factors change, we will likely need to modify our data to fit the new scenario, business requirements, or customer needs.\n\nWe can do this with data refactoring. The APOC library has a set of procedures that can be used to adjust data structure and values across parts or the entirety of the graph. In this section, we will take a look at using several of these procedures to alter our data and respond to potential needs.",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:20:58.156",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348036359_2131776212",
      "id": "paragraph_1635348036359_2131776212",
      "dateCreated": "2021-10-27 15:20:36.359",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Inverting relationships\n\nFirst, our data model shows Product nodes that are PART_OF the Category nodes. We might need to change the direction of the relationship if we discover that our queries actually focus on what products a category contains, rather than on the ordered products. We can flip the relationship direction with the apoc.refactor.invert procedure.\n\nFormat: apoc.refactor.invert(rel) YIELD input, output, error\n\nThis procedure has 1 parameter for the relationship (or relationship variable) of the one we want to flip.",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:21:11.347",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348058224_33193473",
      "id": "paragraph_1635348058224_33193473",
      "dateCreated": "2021-10-27 15:20:58.224",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d apoc.refactor.invert Example:\n\nWith our scenario in the last slide, we want to invert the PART_OF relationship between Product and Category nodes. The query below shows us how to use the apoc.refactor.invert procedure to do that.\n\nMATCH (p:Product)-[part:PART_OF]-\u003e(c:Category)\nCALL apoc.refactor.invert(part) YIELD output\nRETURN output\n\nAfter running this statement, we can run our data model query again or retrieve a sample of the data to see the change.\n\nCALL db.schema.visualization\n\nIt worked!",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:21:15.384",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348071412_1417491836",
      "id": "paragraph_1635348071412_1417491836",
      "dateCreated": "2021-10-27 15:21:11.413",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Renaming relationships\n\nNow we might want to rename that relationship, since the idea that a Category is PART_OF a Product conveys the incorrect meaning for our use case. We can do this with the apoc.refactor.rename.type procedure.\n\nFormat: apoc.refactor.rename.type(oldType, newType, [rels])\n\nThe procedure has 3 parameters -\n\n    the string type (name) of the relationship we want to change\n\n    the new string type (name) we want the relationship to have\n\n    (optional) provided list of specific relationships we want to change\n    \n    \n\u003d\u003d apoc.refactor.rename.type Example:\n\nLet’s change the name of our PART_OF relationship between the Category and Product nodes so that it fits our business model more accurately.\n\nCALL apoc.refactor.rename.type(\u0027PART_OF\u0027,\u0027INCLUDES\u0027) yield total\nRETURN total\n\nIn the above statement, we call the procedure and pass in the relationship we want to change (PART_OF) and tell it what we want the new relationship to be called (INCLUDES). Then, we pull the count of how many were updated in the procedure and return that count.\n\nIf we run our visualization statement again, we now will see that a Category INCLUDES a Product, just as we planned.\n\nCALL db.schema.visualization",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:21:32.202",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348082297_1111714116",
      "id": "paragraph_1635348082297_1111714116",
      "dateCreated": "2021-10-27 15:21:22.297",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Grouping nodes into categories\n\nOutside of our product and category data, we also might want to add categorization for other groupings in our graph. For instance, we might want to categorize customers by country to know how our customers are distributed or for ensuring we have enough support staff to manage larger customer bases in different areas.\n\nWe can use the apoc.refactor.categorize procedure to extract country information from our Customer nodes and create new Country nodes out of it.\n\nFormat: apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize)\n\nThe procedure has up to 7 parameters -\n\n    the property on the existing node we want to use to create the new node\n\n    the type for the new relationship for connecting the existing node to the new node\n\n    whether the relationship is outgoing or not\n\n    the label for the new node\n\n    the key property name we want on the new node\n\n    any additional properties we’d like copied from the old node to the new\n\n    if we have a lot of nodes to update, we can specify to do it in batches\n\n\u003d\u003d apoc.refactor.categorize Example:\n\nBefore we can execute this procedure, we need to put a constraint on the new node and property key. That can be done with the statement below.\n\nCREATE CONSTRAINT ON (c:Country) ASSERT c.countryName IS UNIQUE;\n\nWe will want to wait a few minutes for the constraint to come online, and we can check that by running the db.indexes procedure. Then, we can add our new Country node categories with the following procedure:\n\nCALL apoc.refactor.categorize(\u0027country\u0027, \u0027LOCATED_IN\u0027, true, \u0027Country\u0027, \u0027countryName\u0027, [], 100)\n\nHere, we have specified that we want to take the country property, which is on the Customer nodes and create a LOCATED_IN relationship that is outgoing from the customer to a new Country node with the property called countryName on the new node.\n\nNote: This procedure will remove the country property from the Customer nodes and move them to Country, rather than making a copy of the property to the new nodes.\n\n\u003d\u003d Verify categories\n\nNow, if we run either our visualization or a sample data query, we can verify. Here, we will run a sample data query to see move of the property from Customer to Country.\n\nMATCH (c:Customer)-[rel]-\u003e(other)\nRETURN c, rel, other\n\nIf you click on a Customer node in the result set, you can see that the country property from customers no longer exists on those nodes and has been moved over to new Country nodes as countryName property. Everything looks as we expect it!\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:21:57.576",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348112816_1621294288",
      "id": "paragraph_1635348112816_1621294288",
      "dateCreated": "2021-10-27 15:21:52.816",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Refactor relationships to other nodes\n\nTaking refactoring to the next level, we may want to change existing structure of our graph to represent the idea that customers purchase products, rather than orders. So, instead of having Customer PURCHASED Order, as we do now, it could be that Customer PURCHASED Product. This could help us see more easily which products are most popular or prioritize stocking of products that larger customers rely upon.\n\nThe apoc.refactor.to procedure can help us do that.\n\nFormat: apoc.refactor.to(relationship, endNode)\n\nThe procedure has 2 parameters -\n\n    the relationship that we want to change\n\n    the node where we want the relationship to go\n\n\u003d\u003d apoc.refactor.to Example:\n\nWe can alter where the PURCHASED relationship goes with the APOC code below.\n\nMATCH (c:Customer)-[rel:PURCHASED]-(o:Order)-[rel2:ORDERS]-(p:Product)\nCALL apoc.refactor.to(rel, p) YIELD output\nRETURN output\n\nFor verification, we can retrieve some customers and related entities to see that now Customer nodes are connected to Product nodes directly with a PURCHASED relationship.\n\nMATCH (c:Customer)-[rel]-(other)\nRETURN c, rel, other LIMIT 50\n\nWith this new structure, we can run queries to see how many different products a customer has purchased, how many products within specific categories, and most similar customers (based on products in common) without going through the Order nodes to find this information.\n\nNote: We have also diluted our order tracking where we no longer can easily tell which orders a specific customer made. Refactoring may make some queries easier, but others more complex. Impacts of changes should be evaluated.\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:22:09.321",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348117637_648932751",
      "id": "paragraph_1635348117637_648932751",
      "dateCreated": "2021-10-27 15:21:57.637",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Condensing multiple relationships\n\nWith our last update, you may have noticed that some customers have purchased certain products multiple times, causing multiple PURCHASED relationships to appear between a Customer and Product node when we moved the relationship from individual orders to more general products. We can condense these multiple relationships into a single PURCHASED relationship, as well as add a count property for the number of times a certain product has been ordered by that customer.\n\nThe apoc.refactor.mergeRelationships procedure can help.\n\nFormat: apoc.refactor.mergeRelationships([rel1, rel2])\n\nThe procedure has 2 parameters -\n\n    a list of the relationships we want to merge\n\n    any configuration for whether we want properties to be overwritten, discarded, or combined\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:22:17.720",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348136638_535583225",
      "id": "paragraph_1635348136638_535583225",
      "dateCreated": "2021-10-27 15:22:16.638",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d apoc.refactor.mergeRelationships Example:\n\nNow, we can go ahead and see this in action to condense our relationships between customers and products to a single relationship and tracking the number of times a customer has purchased a particular product.\n\nMATCH (c:Customer)-[r:PURCHASED]-\u003e(p:Product)\nWITH c, p, collect(r) as rels, count(r) as relNum\nCALL apoc.refactor.mergeRelationships(rels, {properties: \u0027discard\u0027}) yield rel\nSET rel.purchaseCount \u003d relNum\nRETURN rel\n\nIn our query, we find Customer nodes with a PURCHASED relationship to Product nodes. We then aggregate those patterns into unique rows (based on aggregations for customer and product nodes), as well as collect the relationships into a list (so we can merge them) and count the relationships to store. The next line calls the procedure and passes in the list of relationships, adding configuration to discard properties on duplicate relationships and outputs the relationships from the merge. Next, we set the purchaseCount property on each relationship with the count of purchases between individual customers and products and return the results.\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:22:27.998",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348147110_48008613",
      "id": "paragraph_1635348147110_48008613",
      "dateCreated": "2021-10-27 15:22:27.110",
      "status": "READY"
    },
    {
      "text": "%md\n\u003d\u003d Verify merged relationships\n\nIf we run a quick sample query like the one below, we can verify that we now have a single relationship between each Customer and Product and that the purchaseCount stores the number of times someone has purchased something.\n\nMATCH (n1:Customer)-[r]-\u003e(n2) RETURN r, n1, n2 LIMIT 25\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:22:45.032",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348151510_2035604528",
      "id": "paragraph_1635348151510_2035604528",
      "dateCreated": "2021-10-27 15:22:31.510",
      "status": "READY"
    },
    {
      "text": "%md\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:22:45.978",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635348165978_2086027420",
      "id": "paragraph_1635348165978_2086027420",
      "dateCreated": "2021-10-27 15:22:45.978",
      "status": "READY"
    }
  ],
  "name": "Refactor data",
  "id": "2GKZNUE99",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}