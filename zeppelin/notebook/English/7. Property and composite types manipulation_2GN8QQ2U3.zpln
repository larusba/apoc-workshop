{
  "paragraphs": [
    {
      "text": "%md\n\n# Collection and map functions\n\nHere is the list of all collection functions\n\n| xref::overview/apoc.coll/apoc.coll.sum.adoc[+++apoc.coll.sum([0.5,1,2.3])+++] | sum of all values in a list\n| xref::overview/apoc.coll/apoc.coll.avg.adoc[+++apoc.coll.avg([0.5,1,2.3])+++] | avg of all values in a list\n| xref::overview/apoc.coll/apoc.coll.min.adoc[+++apoc.coll.min([0.5,1,2.3])+++] | minimum of all values in a list\n| xref::overview/apoc.coll/apoc.coll.max.adoc[+++apoc.coll.max([0.5,1,2.3])+++] | maximum of all values in a list\n| xref::overview/apoc.coll/apoc.coll.sumLongs.adoc[+++apoc.coll.sumLongs([1,3,3])+++] | sums all numeric values in a list\n| xref::overview/apoc.coll/apoc.coll.partition.adoc[+++apoc.coll.partition(list,batchSize)+++] | partitions a list into sublists of `batchSize`\n| xref::overview/apoc.coll/apoc.coll.zip.adoc[+++apoc.coll.zip([list1],[list2])+++] | all values in a list\n| xref::overview/apoc.coll/apoc.coll.pairs.adoc[+++apoc.coll.pairs([1,2,3]) YIELD value+++] | [1,2],[2,3],[3,null]\n| xref::overview/apoc.coll/apoc.coll.pairsMin.adoc[+++apoc.coll.pairsMin([1,2,3]) YIELD value+++] | [1,2],[2,3]\n| xref::overview/apoc.coll/apoc.coll.toSet.adoc[+++apoc.coll.toSet([list])+++] | returns a unique list backed by a set\n| xref::overview/apoc.coll/apoc.coll.sort.adoc[+++apoc.coll.sort(coll)+++] | sort on Collections\n| xref::overview/apoc.coll/apoc.coll.sortNodes.adoc[+++apoc.coll.sortNodes([nodes], \u0027name\u0027)+++] | sort nodes by property, ascending sorting by adding ^ in front of the sorting field\n| xref::overview/apoc.coll/apoc.coll.sortMaps.adoc[+++apoc.coll.sortMaps([maps], \u0027key\u0027)+++] | sort maps by map key, ascending sorting by adding ^ in front of the sorting field\n| xref::overview/apoc.coll/apoc.coll.reverse.adoc[+++apoc.coll.reverse(coll)+++] | returns the reversed list\n| xref::overview/apoc.coll/apoc.coll.contains.adoc[+++apoc.coll.contains(coll, value)+++] | returns true if collection contains the value\n| xref::overview/apoc.coll/apoc.coll.containsAll.adoc[+++apoc.coll.containsAll(coll, values)+++] | optimized contains-all operation (using a HashSet) returns true or false\n| xref::overview/apoc.coll/apoc.coll.containsSorted.adoc[+++apoc.coll.containsSorted(coll, value)+++] | optimized contains on a sorted list operation (Collections.binarySearch) (returns true or false)\n| xref::overview/apoc.coll/apoc.coll.containsAllSorted.adoc[+++apoc.coll.containsAllSorted(coll, value)+++] | optimized contains-all on a sorted list operation (Collections.binarySearch) (returns true or false)\n| xref::overview/apoc.coll/apoc.coll.isEqualCollection.adoc[+++apoc.coll.isEqualCollection(coll, values)+++] | return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)\n| xref::overview/apoc.coll/apoc.coll.union.adoc[+++apoc.coll.union(first, second)+++] | creates the distinct union of the 2 lists\n| xref::overview/apoc.coll/apoc.coll.unionAll.adoc[+++apoc.coll.unionAll(first, second)+++] | creates the full union with duplicates of the two lists\n| xref::overview/apoc.coll/apoc.coll.subtract.adoc[+++apoc.coll.subtract(first, second)+++] | returns unique set of first list with all elements of second list removed\n| xref::overview/apoc.coll/apoc.coll.removeAll.adoc[+++apoc.coll.removeAll(first, second)+++] | returns first list with all elements of second list removed\n| xref::overview/apoc.coll/apoc.coll.intersection.adoc[+++apoc.coll.intersection(first, second)+++] | returns the unique intersection of the two lists\n| xref::overview/apoc.coll/apoc.coll.disjunction.adoc[+++apoc.coll.disjunction(first, second)+++] | returns the disjunct set of the two lists\n| xref::overview/apoc.coll/apoc.coll.split.adoc[+++apoc.coll.split(list,value)+++] | splits collection on given values rows of lists, value itself will not be part of resulting lists\n| xref::overview/apoc.coll/apoc.coll.indexOf.adoc[+++apoc.coll.indexOf(coll, value)+++] | position of value in the list\n| xref::overview/apoc.coll/apoc.coll.shuffle.adoc[+++apoc.coll.shuffle(coll)+++] | returns the shuffled list\n| xref::overview/apoc.coll/apoc.coll.randomItem.adoc[+++apoc.coll.randomItem(coll)+++] | returns a random item from the list\n| xref::overview/apoc.coll/apoc.coll.randomItems.adoc[+++apoc.coll.randomItems(coll, itemCount, allowRepick: false)+++] | returns a list of `itemCount` random items from the list, optionally allowing picked elements to be picked again\n| xref::overview/apoc.coll/apoc.coll.containsDuplicates.adoc[+++apoc.coll.containsDuplicates(coll)+++] | returns true if a collection contains duplicate elements\n| xref::overview/apoc.coll/apoc.coll.duplicates.adoc[+++apoc.coll.duplicates(coll)+++] | returns a list of duplicate items in the collection\n| xref::overview/apoc.coll/apoc.coll.duplicatesWithCount.adoc[+++apoc.coll.duplicatesWithCount(coll)+++] | returns a list of duplicate items in the collection and their count, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}]`)\n| xref::overview/apoc.coll/apoc.coll.occurrences.adoc[+++apoc.coll.occurrences(coll, item)+++] | returns the count of the given item in the collection\n| xref::overview/apoc.coll/apoc.coll.frequencies.adoc[+++apoc.coll.frequencies(coll)+++] | returns a list of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]`)\n| xref::overview/apoc.coll/apoc.coll.frequenciesAsMap.adoc[+++apoc.coll.frequenciesAsMap(coll)+++] | return a map of frequencies of the items in the collection, keyed by `item` and `count` (e.g., `{1: 2, 3: 2}`)\n| xref::overview/apoc.coll/apoc.coll.sortMulti.adoc[+++apoc.coll.sortMulti+++] | sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip\n| xref::overview/apoc.coll/apoc.coll.flatten.adoc[+++apoc.coll.flatten+++] | flattens a nested list\n| xref::overview/apoc.coll/apoc.coll.combinations.adoc[+++apoc.coll.combinations(coll, minSelect, maxSelect:minSelect)+++] | Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive\n| xref::overview/apoc.coll/apoc.coll.elements.adoc[+++CALL apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p+++] | deconstruct subset of mixed list into identifiers of the correct type\n| xref::overview/apoc.coll/apoc.coll.set.adoc[+++apoc.coll.set(coll, index, value)+++] | set index to value\n| xref::overview/apoc.coll/apoc.coll.insert.adoc[+++apoc.coll.insert(coll, index, value)+++] | insert value at index\n| xref::overview/apoc.coll/apoc.coll.insertAll.adoc[+++apoc.coll.insertAll(coll, index, values)+++] | insert values at index\n| xref::overview/apoc.coll/apoc.coll.remove.adoc[+++apoc.coll.remove(coll, index, [length\u003d1])+++] | remove range of values from index to length\n| xref::overview/apoc.coll/apoc.coll.different.adoc[+++apoc.coll.different(values)+++] | returns true if value are different\n| xref::overview/apoc.coll/apoc.coll.fill.adoc[+++apoc.coll.fill(item, count)+++] | returns a list with the given count of items\n| xref::overview/apoc.coll/apoc.coll.sortText.adoc[+++apoc.coll.sortText(coll, conf)+++] | sort on string based collections\n| xref::overview/apoc.coll/apoc.coll.pairWithOffset.adoc[+++apoc.coll.pairWithOffset(values, offset)+++] | returns a list of pairs defined by the offset\n\n\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.503",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eCollection and map functions\u003c/h1\u003e\n\u003cp\u003eHere is the list of all collection functions\u003c/p\u003e\n\u003cp\u003e| xref::overview/apoc.coll/apoc.coll.sum.adoc[+++apoc.coll.sum([0.5,1,2.3])+++] | sum of all values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.avg.adoc[+++apoc.coll.avg([0.5,1,2.3])+++] | avg of all values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.min.adoc[+++apoc.coll.min([0.5,1,2.3])+++] | minimum of all values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.max.adoc[+++apoc.coll.max([0.5,1,2.3])+++] | maximum of all values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sumLongs.adoc[+++apoc.coll.sumLongs([1,3,3])+++] | sums all numeric values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.partition.adoc[+++apoc.coll.partition(list,batchSize)+++] | partitions a list into sublists of \u003ccode\u003ebatchSize\u003c/code\u003e\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.zip.adoc[+++apoc.coll.zip([list1],[list2])+++] | all values in a list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.pairs.adoc[+++apoc.coll.pairs([1,2,3]) YIELD value+++] | [1,2],[2,3],[3,null]\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.pairsMin.adoc[+++apoc.coll.pairsMin([1,2,3]) YIELD value+++] | [1,2],[2,3]\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.toSet.adoc[+++apoc.coll.toSet([list])+++] | returns a unique list backed by a set\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sort.adoc[+++apoc.coll.sort(coll)+++] | sort on Collections\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sortNodes.adoc[+++apoc.coll.sortNodes([nodes], \u0026lsquo;name\u0026rsquo;)+++] | sort nodes by property, ascending sorting by adding ^ in front of the sorting field\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sortMaps.adoc[+++apoc.coll.sortMaps([maps], \u0026lsquo;key\u0026rsquo;)+++] | sort maps by map key, ascending sorting by adding ^ in front of the sorting field\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.reverse.adoc[+++apoc.coll.reverse(coll)+++] | returns the reversed list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.contains.adoc[+++apoc.coll.contains(coll, value)+++] | returns true if collection contains the value\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.containsAll.adoc[+++apoc.coll.containsAll(coll, values)+++] | optimized contains-all operation (using a HashSet) returns true or false\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.containsSorted.adoc[+++apoc.coll.containsSorted(coll, value)+++] | optimized contains on a sorted list operation (Collections.binarySearch) (returns true or false)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.containsAllSorted.adoc[+++apoc.coll.containsAllSorted(coll, value)+++] | optimized contains-all on a sorted list operation (Collections.binarySearch) (returns true or false)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.isEqualCollection.adoc[+++apoc.coll.isEqualCollection(coll, values)+++] | return true if two collections contain the same elements with the same cardinality in any order (using a HashMap)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.union.adoc[+++apoc.coll.union(first, second)+++] | creates the distinct union of the 2 lists\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.unionAll.adoc[+++apoc.coll.unionAll(first, second)+++] | creates the full union with duplicates of the two lists\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.subtract.adoc[+++apoc.coll.subtract(first, second)+++] | returns unique set of first list with all elements of second list removed\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.removeAll.adoc[+++apoc.coll.removeAll(first, second)+++] | returns first list with all elements of second list removed\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.intersection.adoc[+++apoc.coll.intersection(first, second)+++] | returns the unique intersection of the two lists\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.disjunction.adoc[+++apoc.coll.disjunction(first, second)+++] | returns the disjunct set of the two lists\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.split.adoc[+++apoc.coll.split(list,value)+++] | splits collection on given values rows of lists, value itself will not be part of resulting lists\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.indexOf.adoc[+++apoc.coll.indexOf(coll, value)+++] | position of value in the list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.shuffle.adoc[+++apoc.coll.shuffle(coll)+++] | returns the shuffled list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.randomItem.adoc[+++apoc.coll.randomItem(coll)+++] | returns a random item from the list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.randomItems.adoc[+++apoc.coll.randomItems(coll, itemCount, allowRepick: false)+++] | returns a list of \u003ccode\u003eitemCount\u003c/code\u003e random items from the list, optionally allowing picked elements to be picked again\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.containsDuplicates.adoc[+++apoc.coll.containsDuplicates(coll)+++] | returns true if a collection contains duplicate elements\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.duplicates.adoc[+++apoc.coll.duplicates(coll)+++] | returns a list of duplicate items in the collection\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.duplicatesWithCount.adoc[+++apoc.coll.duplicatesWithCount(coll)+++] | returns a list of duplicate items in the collection and their count, keyed by \u003ccode\u003eitem\u003c/code\u003e and \u003ccode\u003ecount\u003c/code\u003e (e.g., \u003ccode\u003e[{item: xyz, count:2}, {item:zyx, count:5}]\u003c/code\u003e)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.occurrences.adoc[+++apoc.coll.occurrences(coll, item)+++] | returns the count of the given item in the collection\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.frequencies.adoc[+++apoc.coll.frequencies(coll)+++] | returns a list of frequencies of the items in the collection, keyed by \u003ccode\u003eitem\u003c/code\u003e and \u003ccode\u003ecount\u003c/code\u003e (e.g., \u003ccode\u003e[{item: xyz, count:2}, {item:zyx, count:5}, {item:abc, count:1}]\u003c/code\u003e)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.frequenciesAsMap.adoc[+++apoc.coll.frequenciesAsMap(coll)+++] | return a map of frequencies of the items in the collection, keyed by \u003ccode\u003eitem\u003c/code\u003e and \u003ccode\u003ecount\u003c/code\u003e (e.g., \u003ccode\u003e{1: 2, 3: 2}\u003c/code\u003e)\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sortMulti.adoc[+++apoc.coll.sortMulti+++] | sort list of maps by several sort fields (ascending with ^ prefix) and optionally applies limit and skip\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.flatten.adoc[+++apoc.coll.flatten+++] | flattens a nested list\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.combinations.adoc[+++apoc.coll.combinations(coll, minSelect, maxSelect:minSelect)+++] | Returns collection of all combinations of list elements of selection size between minSelect and maxSelect (default:minSelect), inclusive\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.elements.adoc[+++CALL apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p+++] | deconstruct subset of mixed list into identifiers of the correct type\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.set.adoc[+++apoc.coll.set(coll, index, value)+++] | set index to value\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.insert.adoc[+++apoc.coll.insert(coll, index, value)+++] | insert value at index\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.insertAll.adoc[+++apoc.coll.insertAll(coll, index, values)+++] | insert values at index\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.remove.adoc[+++apoc.coll.remove(coll, index, [length\u003d1])+++] | remove range of values from index to length\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.different.adoc[+++apoc.coll.different(values)+++] | returns true if value are different\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.fill.adoc[+++apoc.coll.fill(item, count)+++] | returns a list with the given count of items\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.sortText.adoc[+++apoc.coll.sortText(coll, conf)+++] | sort on string based collections\u003cbr /\u003e\n| xref::overview/apoc.coll/apoc.coll.pairWithOffset.adoc[+++apoc.coll.pairWithOffset(values, offset)+++] | returns a list of pairs defined by the offset\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349487755_663980320",
      "id": "paragraph_1635349487755_663980320",
      "dateCreated": "2021-10-27 15:44:47.756",
      "dateStarted": "2021-10-29 12:08:50.968",
      "dateFinished": "2021-10-29 12:08:51.067",
      "status": "FINISHED"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.coll.sum([1,2,3,4,5]) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:10:12.312",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 84.0057,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "output": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/undefined",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "output\n15.0\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509218886_1080836149",
      "id": "paragraph_1635509218886_1080836149",
      "dateCreated": "2021-10-29 12:06:58.887",
      "dateStarted": "2021-10-29 12:08:51.184",
      "dateFinished": "2021-10-29 12:08:51.693",
      "status": "FINISHED"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.coll.intersection([1,2,3,4,5], [3,4,5]) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:10:19.846",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 84.0057,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "output": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/undefined",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "output\n[3,4,5]\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509250859_2058648590",
      "id": "paragraph_1635509250859_2058648590",
      "dateCreated": "2021-10-29 12:07:30.860",
      "dateStarted": "2021-10-29 12:08:51.807",
      "dateFinished": "2021-10-29 12:08:51.971",
      "status": "FINISHED"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.coll.shuffle([1,3,5,7,9]) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:10:25.446",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 114.006,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "output": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/undefined",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "TABLE",
            "data": "output\n[5,3,9,1,7]\n"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509267603_1766584627",
      "id": "paragraph_1635509267603_1766584627",
      "dateCreated": "2021-10-29 12:07:47.603",
      "dateStarted": "2021-10-29 12:10:25.473",
      "dateFinished": "2021-10-29 12:10:25.499",
      "status": "FINISHED"
    },
    {
      "text": "%neo4j\n\nmatch (n)\nRETURN apoc.coll.randomItem(collect(n)) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:11:13.609",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {
          "0": {
            "graph": {
              "mode": "table",
              "height": 300.0,
              "optionOpen": false,
              "setting": {
                "table": {
                  "tableGridState": {},
                  "tableColumnTypeState": {
                    "names": {
                      "id": "string",
                      "label": "string",
                      "name": "string",
                      "born": "string"
                    },
                    "updated": false
                  },
                  "tableOptionSpecHash": "[{\"name\":\"useFilter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable filter for columns\"},{\"name\":\"showPagination\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable pagination for better navigation\"},{\"name\":\"showAggregationFooter\",\"valueType\":\"boolean\",\"defaultValue\":false,\"widget\":\"checkbox\",\"description\":\"Enable a footer for displaying aggregated values\"}]",
                  "tableOptionValue": {
                    "useFilter": false,
                    "showPagination": false,
                    "showAggregationFooter": false
                  },
                  "updated": false,
                  "initialized": false
                }
              },
              "commonSetting": {}
            }
          }
        },
        "editorSetting": {
          "language": "text",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/undefined",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "NETWORK",
            "data": "{\"nodes\":[{\"id\":38,\"data\":{\"name\":\"Renee Zellweger\",\"born\":1969},\"label\":\"Person\"}],\"edges\":[],\"labels\":{\"Movie\":\"#6621E1\",\"Person\":\"#387194\"},\"types\":[\"ACTED_IN\",\"REVIEWED\",\"PRODUCED\",\"WROTE\",\"FOLLOWS\",\"DIRECTED\"],\"directed\":true}"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509285098_1819157902",
      "id": "paragraph_1635509285098_1819157902",
      "dateCreated": "2021-10-29 12:08:05.098",
      "dateStarted": "2021-10-29 12:11:13.633",
      "dateFinished": "2021-10-29 12:11:13.698",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n## Map function\n\n| xref::overview/apoc.map/apoc.map.flatten.adoc[+++apoc.map.flatten(map,delimiter:\".\")+++] | flatten a nested map into a single-level map, for example turning {parent:{child:1}} into {\"parent.child\":1}\n| xref::overview/apoc.map/apoc.map.fromNodes.adoc[+++apoc.map.fromNodes(label, property)+++] | creates map from nodes with this label grouped by property\n\n| xref::overview/apoc.map/apoc.map.fromPairs.adoc[+++apoc.map.fromPairs([[key,value],[key2,value2],...])+++] | creates map from list with key-value pairs\n| xref::overview/apoc.map/apoc.map.fromLists.adoc[+++apoc.map.fromLists([keys],[values])+++] | creates map from a keys and a values list\n| xref::overview/apoc.map/apoc.map.fromValues.adoc[+++apoc.map.fromValues([key,value,key1,value1])+++] | creates map from alternating keys and values in a list\n| xref::overview/apoc.map/apoc.map.merge.adoc[+++apoc.map.merge({first},{second}) yield value+++] | creates map from merging the two source maps\n| xref::overview/apoc.map/apoc.map.mergeList.adoc[+++apoc.map.mergeList([{maps}]) yield value+++] | merges all maps in the list into one\n| xref::overview/apoc.map/apoc.map.setKey.adoc[+++apoc.map.setKey(map,key,value)+++] | returns the map with the value for this key added or replaced\n| xref::overview/apoc.map/apoc.map.removeKey.adoc[+++apoc.map.removeKey(map,key,{recursive:true/false})+++] | returns the map with the key removed (recursively if recursive is true)\n| xref::overview/apoc.map/apoc.map.removeKeys.adoc[+++apoc.map.removeKeys(map,[keys],{recursive:true/false})+++] | returns the map with the keys removed (recursively if recursive is true)\n| xref::overview/apoc.map/apoc.map.clean.adoc[+++apoc.map.clean(map,[keys],[values]) yield value+++] | removes the keys and values (e.g. null-placeholders) contained in those lists, good for data cleaning from CSV/JSON\n\n| xref::overview/apoc.map/apoc.map.groupBy.adoc[+++apoc.map.groupBy([maps/nodes/relationships],\u0027key\u0027) yield value+++] | creates a map of the list keyed by the given property, with single values\n| xref::overview/apoc.map/apoc.map.groupByMulti.adoc[+++apoc.map.groupByMulti([maps/nodes/relationships],\u0027key\u0027) yield value+++] | creates a map of the list keyed by the given property, with list values\n| xref::overview/apoc.map/apoc.map.sortedProperties.adoc[+++apoc.map.sortedProperties(map, ignoreCase:true)+++] | returns a list of key/value list pairs, with pairs sorted by keys alphabetically, with optional case sensitivity\n| xref::overview/apoc.map/apoc.map.updateTree.adoc[+++apoc.map.updateTree(tree,key,[[value,{data}]])+++] | returns map - adds the \\{data} map on each level of the nested tree, where the key-value pairs match\n| xref::overview/apoc.map/apoc.map.values.adoc[+++apoc.map.values(map, [key1,key2,key3,...],[addNullsForMissing])+++] | returns list of values indicated by the keys\n| xref::overview/apoc.map/apoc.map.submap.adoc[+++apoc.map.submap(map,keys,[[defaults]],[fail\u003dtrue])+++] | returns submap for keys or throws exception if one of the key doesn\u0027t exist and no default value given at that position\n| xref::overview/apoc.map/apoc.map.mget.adoc[+++apoc.map.mget(map,keys,[[defaults]],[fail\u003dtrue])+++] | returns list of values for keys or throws exception if one of the key doesn\u0027t exist and no default value given at that position\n| xref::overview/apoc.map/apoc.map.get.adoc[+++apoc.map.get(map,key,[default],[fail\u003dtrue])+++] | returns value for key or throws exception if key doesn\u0027t exist and no default given\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:12:09.037",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509480064_1011363535",
      "id": "paragraph_1635509480064_1011363535",
      "dateCreated": "2021-10-29 12:11:20.064",
      "status": "READY"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.map.fromLists(\n    [\"name\", \"dob\"],\n    [\"Cristiano Ronaldo\", date(\"1985-02-05\")]\n) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:13:34.412",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509532909_971464630",
      "id": "paragraph_1635509532909_971464630",
      "dateCreated": "2021-10-29 12:12:12.909",
      "status": "READY"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.map.merge(\n    {name: \"Cristiano Ronaldo\", dob: date(\"1985-02-05\")},\n    {country: \"Portugal\"}\n) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:13:44.033",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509615873_1036558899",
      "id": "paragraph_1635509615873_1036558899",
      "dateCreated": "2021-10-29 12:13:35.873",
      "status": "READY"
    },
    {
      "text": "%neo4j\n\nRETURN apoc.map.groupBy([\n\t{name: \"Cristiano Ronaldo\", club: \"Juventus\"},\n    {name: \"Lionel Messi\", club: \"Barcelona\"},\n    {name: \"Aaron Ramsey\", club: \"Juventus\"},\n    {name: \"Luiz Suarez\", club: \"Barcelona\"}\n], \"club\") AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:14:01.530",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509639889_588550444",
      "id": "paragraph_1635509639889_588550444",
      "dateCreated": "2021-10-29 12:13:59.889",
      "status": "READY"
    },
    {
      "text": "%neo4j\n\nWITH {name:\"Cristiano Ronaldo\",country:\"Portugal\",dob:date(\"1985-02-05\")} AS map\nRETURN apoc.map.sortedProperties(map) AS output;",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:14:20.556",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635509642996_603828793",
      "id": "paragraph_1635509642996_603828793",
      "dateCreated": "2021-10-29 12:14:02.996",
      "status": "READY"
    },
    {
      "text": "%md\n\n\u003d\u003d Text function\nhttps://neo4j.com/labs/apoc/4.1/misc/text-functions/\n// there are a bunch of useful text functions\n\n\n\n[[text-functions-overview]]\n\u003d\u003d Overview Text Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| xref::overview/apoc.text/apoc.text.indexOf.adoc[apoc.text.indexOf(text, lookup, offset\u003d0, to\u003d-1\u003d\u003dlen)] | find the first occurence of the lookup string in the text, from inclusive, to exclusive,, -1 if not found, null if text is null.\n| xref::overview/apoc.text/apoc.text.indexesOf.adoc[apoc.text.indexesOf(text, lookup, from\u003d0, to\u003d-1\u003d\u003dlen)] | finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.\n| xref::overview/apoc.text/apoc.text.replace.adoc[apoc.text.replace(text, regex, replacement)] | replace each substring of the given string that matches the given regular expression with the given replacement.\n| xref::overview/apoc.text/apoc.text.regexGroups.adoc[apoc.text.regexGroups(text, regex)] | returns an array containing a nested array for each match. The inner array contains all match groups.\n| xref::overview/apoc.text/apoc.text.join.adoc[+++apoc.text.join([\u0027text1\u0027,\u0027text2\u0027,...], delimiter)+++] | join the given strings with the given delimiter.\n| xref::overview/apoc.text/apoc.text.repeat.adoc[apoc.text.repeat(\u0027item\u0027,count)] | multiply the given string with the given count\n| xref::overview/apoc.text/apoc.text.format.adoc[apoc.text.format(text,[params],language)] | sprintf format the string with the params given, and optional param language (default value is \u0027en\u0027).\n| xref::overview/apoc.text/apoc.text.lpad.adoc[apoc.text.lpad(text,count,delim)] | left pad the string to the given width\n| xref::overview/apoc.text/apoc.text.rpad.adoc[apoc.text.rpad(text,count,delim)] | right pad the string to the given width\n| xref::overview/apoc.text/apoc.text.random.adoc[apoc.text.random(length, [valid])] | returns a random string to the specified length\n| xref::overview/apoc.text/apoc.text.capitalize.adoc[apoc.text.capitalize(text)] | capitalise the first letter of the word\n| xref::overview/apoc.text/apoc.text.capitalizeAll.adoc[apoc.text.capitalizeAll(text)] | capitalise the first letter of every word in the text\n| xref::overview/apoc.text/apoc.text.decapitalize.adoc[apoc.text.decapitalize(text)] | decapitalize the first letter of the word\n| xref::overview/apoc.text/apoc.text.decapitalizeAll.adoc[apoc.text.decapitalizeAll(text)] | decapitalize the first letter of all words\n| xref::overview/apoc.text/apoc.text.swapCase.adoc[apoc.text.swapCase(text)] | Swap the case of a string\n| xref::overview/apoc.text/apoc.text.camelCase.adoc[apoc.text.camelCase(text)] | Convert a string to camelCase\n| xref::overview/apoc.text/apoc.text.upperCamelCase.adoc[apoc.text.upperCamelCase(text)] | Convert a string to UpperCamelCase\n| xref::overview/apoc.text/apoc.text.snakeCase.adoc[apoc.text.snakeCase(text)] | Convert a string to snake-case\n| xref::overview/apoc.text/apoc.text.toUpperCase.adoc[apoc.text.toUpperCase(text)] | Convert a string to UPPER_CASE\n| xref::overview/apoc.text/apoc.text.charAt.adoc[apoc.text.charAt(text, index)] | Returns the decimal value of the character at the given index\n| xref::overview/apoc.text/apoc.text.code.adoc[apoc.text.code(codepoint)] | Returns the unicode character of the given codepoint\n| xref::overview/apoc.text/apoc.text.hexCharAt.adoc[apoc.text.hexCharAt(text, index)] | Returns the hex value string of the character at the given index\n| xref::overview/apoc.text/apoc.text.hexValue.adoc[apoc.text.hexValue(value)] | Returns the hex value string of the given value\n| xref::overview/apoc.text/apoc.text.byteCount.adoc[+++apoc.text.byteCount(text,[charset])+++] | return size of text in bytes\n| xref::overview/apoc.text/apoc.text.bytes.adoc[+++apoc.text.bytes(text,[charset])+++] | return bytes of the text\n| xref::overview/apoc.text/apoc.text.toCypher.adoc[apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end})] | tries its best to convert the value to a cypher-property-string\n| xref::overview/apoc.text/apoc.text.base64Encode.adoc[apoc.text.base64Encode(text)] | Encode a string with Base64\n| xref::overview/apoc.text/apoc.text.base64Decode.adoc[apoc.text.base64Decode(text)] | Decode Base64 encoded string\n| xref::overview/apoc.text/apoc.text.base64UrlEncode.adoc[apoc.text.base64UrlEncode(url)] | Encode a url with Base64\n| xref::overview/apoc.text/apoc.text.base64UrlDecode.adoc[apoc.text.base64UrlDecode(url)] | Decode Base64 encoded url\n|\u003d\u003d\u003d\n\nThe `replace`, `split` and `regexGroups` functions work with regular expressions.\n\n\n[[text-functions-data-extraction]]\n\u003d\u003d Data Extraction\n\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.data.url(\u0027url\u0027) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\n| apoc.data.email(\u0027email_address\u0027) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\n| apoc.data.domain(email_or_url) | *deprecated* returns domain part of the value\n|\u003d\u003d\u003d\n\n[[text-functions-text-similarity]]\n\u003d\u003d Text Similarity Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u003c 3 then 0, length \u003c 5 then 1, else 2).\n|\u003d\u003d\u003d\nThe replace, split and regexGroups functions work with regular expressions.\n\n\n\n\n\u003d\u003d Data extraction\n\n\n\n\u003d\u003d Text Similarity\n\n// useful to data clean purpose\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u003c 3 then 0, length \u003c 5 then 1, else 2).\n|\u003d\u003d\u003d\n\n\n.will return \u0027HelloWorld\u0027\n[source,cypher]\n----\nRETURN apoc.text.replace(\u0027Hello World!\u0027, \u0027[^a-zA-Z]\u0027, \u0027\u0027)\n----\n\n[source,cypher]\n----\nRETURN apoc.text.regexGroups(\u0027abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0027,\u0027\u003clink (\\\\w+)\u003e(\\\\w+)\u003c/link\u003e\u0027) AS result\n\n// [[\"\u003clink xxx1\u003eyyy1\u003c/link\u003e\", \"xxx1\", \"yyy1\"], [\"\u003clink xxx2\u003eyyy2\u003c/link\u003e\", \"xxx2\", \"yyy2\"]]\n----\n\n\n\n\u003d\u003d\u003d Compare the  strings with the Levenshtein distance\n\nCompare the given strings with the `StringUtils.distance(text1, text2)` method (Levenshtein).\n\n[source,cypher]\n----\nRETURN apoc.text.distance(\"Levenshtein\", \"Levenstein\") // 1\n----\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.data.url(\u0027url\u0027) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\n| apoc.data.email(\u0027email_address\u0027) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\n| apoc.data.domain(email_or_url) | *deprecated* returns domain part of the value\n|\u003d\u003d\u003d\n\n\n[[text-functions-phonetic-comparison]]\n\u003d\u003d Phonetic Comparison Functions\n\nThe phonetic text (soundex) functions allow you to compute the soundex encoding of a given string.\nThere is also a procedure to compare how similar two strings sound under the soundex algorithm.\nAll soundex procedures by default assume the used language is US English.\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.phonetic(value) | Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings\n| apoc.text.doubleMetaphone(value) | Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings\n| apoc.text.clean(text) | strip the given string of everything except alpha numeric characters and convert it to lower case.\n| apoc.text.compareCleaned(text1, text2) | compare the given strings stripped of everything except alpha numeric characters converted to lower case.\n|\u003d\u003d\u003d\n\n.Procedure\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta | Compute the US_ENGLISH soundex character difference between two given strings\n|\u003d\u003d\u003d\n\n[source,cypher]\n----\n// will return \u0027H436\u0027\nRETURN apoc.text.phonetic(\u0027Hello, dear User!\u0027)\n----\n\n[source,cypher]\n----\n// will return \u00274\u0027  (very similar)\nRETURN apoc.text.phoneticDelta(\u0027Hello Mr Rabbit\u0027, \u0027Hello Mr Ribbit\u0027)\n----\n\n[[text-functions-formatting-text]]\n\u003d\u003d Formatting Text\n\nFormat the string with the params given, and optional param language.\n\n.without language param (\u0027en\u0027 default)\n\n[source,cypher]\n----\nRETURN apoc.text.format(\u0027ab%s %d %.1f %s%n\u0027,[\u0027cd\u0027,42,3.14,true]) AS value // abcd 42 3.1 true\n----\n\n.with language param\n\n[source,cypher]\n----\nRETURN apoc.text.format(\u0027ab%s %d %.1f %s%n\u0027,[\u0027cd\u0027,42,3.14,true],\u0027it\u0027) AS value // abcd 42 3,1 true\n----\n\n[[text-functions-string-search]]\n\u003d\u003d String Search\n\nThe `indexOf` function, provides the fist occurrence of the given `lookup` string within the `text`, or -1 if not found.\nIt can optionally take `from` (inclusive) and `to` (exclusive) parameters.\n\n[source,cypher]\n----\nRETURN apoc.text.indexOf(\u0027Hello World!\u0027, \u0027World\u0027) // 6\n----\n\nThe `indexesOf` function, provides all occurrences of the given lookup string within the text, or empty list if not found.\nIt can optionally take `from` (inclusive) and `to` (exclusive) parameters.\n\n\n[source,cypher]\n----\nRETURN apoc.text.indexesOf(\u0027Hello World!\u0027, \u0027o\u0027,2,9) // [4,7]\n----\n\nIf you want to get a substring starting from your index match, you can use this\n\n.returns `World!`\n[source,cypher]\n----\nWITH \u0027Hello World!\u0027 as text, length(text) as len\nWITH text, len, apoc.text.indexOf(text, \u0027World\u0027,3) as index\nRETURN substring(text, case index when -1 then len-1 else index end, len);\n----\n\n[[text-functions-regex]]\n\u003d\u003d Regular Expressions\n\n.will return \u0027HelloWorld\u0027\n[source,cypher]\n----\nRETURN apoc.text.replace(\u0027Hello World!\u0027, \u0027[^a-zA-Z]\u0027, \u0027\u0027)\n----\n\n[source,cypher]\n----\nRETURN apoc.text.regexGroups(\u0027abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0027,\u0027\u003clink (\\\\w+)\u003e(\\\\w+)\u003c/link\u003e\u0027) AS result\n\n// [[\"\u003clink xxx1\u003eyyy1\u003c/link\u003e\", \"xxx1\", \"yyy1\"], [\"\u003clink xxx2\u003eyyy2\u003c/link\u003e\", \"xxx2\", \"yyy2\"]]\n----\n\n\n[[text-functions-split-join]]\n\u003d\u003d Split and Join\n\n.will split with the given regular expression return [\u0027Hello\u0027, \u0027World\u0027]\n[source,cypher]\n----\nRETURN apoc.text.split(\u0027Hello   World\u0027, \u0027 +\u0027)\n----\n\n.will return \u0027Hello World\u0027\n[source,cypher]\n----\nRETURN apoc.text.join([\u0027Hello\u0027, \u0027World\u0027], \u0027 \u0027)\n----\n\n[[text-functions-data-cleaning]]\n\u003d\u003d Data Cleaning\n\n.will return \u0027helloworld\u0027\n[source,cypher]\n----\nRETURN apoc.text.clean(\u0027Hello World!\u0027)\n----\n\n.will return `true`\n[source,cypher]\n----\nRETURN apoc.text.compareCleaned(\u0027Hello World!\u0027, \u0027_hello-world_\u0027)\n----\n\n.will return only \u0027Hello World!\u0027\n[source,cypher]\n----\nUNWIND [\u0027Hello World!\u0027, \u0027hello worlds\u0027] as text\nRETURN apoc.text.filterCleanMatches(text, \u0027hello_world\u0027) as text\n----\n\nThe clean functionality can be useful for cleaning up slightly dirty text data with inconsistent formatting for non-exact comparisons.\n\nCleaning will strip the string of all non-alphanumeric characters (including spaces) and convert it to lower case.\n\n[[text-functions-case-change]]\n\u003d\u003d Case Change Functions\n\n.Capitalise the first letter of the word with `capitalize`\n[source,cypher]\n----\nRETURN apoc.text.capitalize(\"neo4j\") // \"Neo4j\"\n----\n\n.Capitalise the first letter of every word in the text with `capitalizeAll`\n[source,cypher]\n----\nRETURN apoc.text.capitalizeAll(\"graph database\") // \"Graph Database\"\n----\n\n.Decapitalize the first letter of the string with `decapitalize`\n[source,cypher]\n----\nRETURN apoc.text.decapitalize(\"Graph Database\") // \"graph Database\"\n----\n\n.Decapitalize the first letter of all words with `decapitalizeAll`\n[source,cypher]\n----\nRETURN apoc.text.decapitalizeAll(\"Graph Databases\") // \"graph databases\"\n----\n\n.Swap the case of a string with `swapCase`\n[source,cypher]\n----\nRETURN apoc.text.swapCase(\"Neo4j\") // nEO4J\n----\n\n.Convert a string to lower camelCase with `camelCase`\n[source,cypher]\n----\nRETURN apoc.text.camelCase(\"FOO_BAR\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foo bar\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foo22 bar\");  // \"foo22Bar\"\nRETURN apoc.text.camelCase(\"foo-bar\");    // \"fooBar\"\nRETURN apoc.text.camelCase(\"Foobar\");     // \"foobar\"\nRETURN apoc.text.camelCase(\"Foo$$Bar\");   // \"fooBar\"\n----\n\n.Convert a string to UpperCamelCase with `upperCamelCase`\n[source,cypher]\n----\nRETURN apoc.text.upperCamelCase(\"FOO_BAR\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foo bar\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foo22 bar\"); // \"Foo22Bar\"\nRETURN apoc.text.upperCamelCase(\"foo-bar\");   // \"FooBar\"\nRETURN apoc.text.upperCamelCase(\"Foobar\");    // \"Foobar\"\nRETURN apoc.text.upperCamelCase(\"Foo$$Bar\");  // \"FooBar\"\n----\n\n.Convert a string to snake-case with `snakeCase`\n[source,cypher]\n----\nRETURN apoc.text.snakeCase(\"test Snake Case\"); // \"test-snake-case\"\nRETURN apoc.text.snakeCase(\"FOO_BAR\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"fooBar\");          // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"foo-bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo bar\");         // \"foo-bar\"\nRETURN apoc.text.snakeCase(\"Foo  bar\");        // \"foo-bar\"\n----\n\n.Convert a string to UPPER_CASE with `toUpperCase`\n[source,cypher]\n----\nRETURN apoc.text.toUpperCase(\"test upper case\"); // \"TEST_UPPER_CASE\"\nRETURN apoc.text.toUpperCase(\"FooBar\");          // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"fooBar\");          // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo-bar\");         // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo--bar\");        // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo$$bar\");        // \"FOO_BAR\"\nRETURN apoc.text.toUpperCase(\"foo 22 bar\");      // \"FOO_22_BAR\"\n----\n\n\n[[text-functions-base64-encoding-decoding]]\n\u003d\u003d Base64 De- and Encoding\n\nEncode or decode a string in base64 or base64Url\n\n.Encode base 64\n[source,cypher]\n----\nRETURN apoc.text.base64Encode(\"neo4j\") // bmVvNGo\u003d\n----\n\n.Decode base 64\n[source,cypher]\n----\nRETURN apoc.text.base64Decode(\"bmVvNGo\u003d\") // neo4j\n----\n\n\n.Encode base 64 URL\n[source,cypher]\n----\nRETURN apoc.text.base64UrlEncode(\"http://neo4j.com/?test\u003dtest\") // aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\n----\n\n.Decode base 64 URL\n[source,cypher]\n----\nRETURN apoc.text.base64UrlDecode(\"aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\") // http://neo4j.com/?test\u003dtest\n----\n\n[[text-functions-random-string]]\n\u003d\u003d Random String\n\nYou can generate a random string to a specified length by calling `apoc.text.random` with a length parameter and optional string of valid characters.\n\nThe `valid` parameter will accept the following regex patterns, alternatively you can provide a string of letters and/or characters.\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| Pattern | Description\n| A-Z | A-Z in uppercase\n| a-z | A-Z in lowercase\n| 0-9 | Numbers 0-9 inclusive\n|\u003d\u003d\u003d\n\n.The following call will return a random string including uppercase letters, numbers and `.` and `$` characters.\n[source,cypher]\n----\nRETURN apoc.text.random(10, \"A-Z0-9.$\")\n----\n\n[[text-functions-extract-domain]]\n\u003d\u003d Extract Domain\n\nThe User Function `apoc.data.domain` will take a url or email address and try to determine the domain name.\nThis can be useful to make easier correlations and equality tests between differently formatted email addresses, and between urls to the same domains but specifying different locations.\n\n[source,cypher]\n----\nWITH \u0027foo@bar.com\u0027 AS email\nRETURN apoc.data.domain(email) // will return \u0027bar.com\u0027\n----\n\n[source,cypher]\n----\nWITH \u0027http://www.example.com/all-the-things\u0027 AS url\nRETURN apoc.data.domain(url) // will return \u0027www.example.com\u0027\n----\n\n[[text-functions-hashing]]\n\u003d\u003d Hashing Functions\n\n[cols\u003d\"5m,5\"]\n|\u003d\u003d\u003d\n| apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list\n| apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list\n|\u003d\u003d\u003d\n\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:15:05.999",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Text function\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/misc/text-functions/\"\u003ehttps://neo4j.com/labs/apoc/4.1/misc/text-functions/\u003c/a\u003e\u003cbr /\u003e\n// there are a bunch of useful text functions\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-overview\"\u003etext-functions-overview\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Overview Text Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.indexOf.adoc[apoc.text.indexOf(text, lookup, offset\u003d0, to\u003d-1\u003d\u003dlen)] | find the first occurence of the lookup string in the text, from inclusive, to exclusive,, -1 if not found, null if text is null.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.indexesOf.adoc[apoc.text.indexesOf(text, lookup, from\u003d0, to\u003d-1\u003d\u003dlen)] | finds all occurences of the lookup string in the text, return list, from inclusive, to exclusive, empty list if not found, null if text is null.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.replace.adoc[apoc.text.replace(text, regex, replacement)] | replace each substring of the given string that matches the given regular expression with the given replacement.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.regexGroups.adoc[apoc.text.regexGroups(text, regex)] | returns an array containing a nested array for each match. The inner array contains all match groups.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.join.adoc[+++apoc.text.join([\u0026lsquo;text1\u0026rsquo;,\u0026lsquo;text2\u0026rsquo;,\u0026hellip;], delimiter)+++] | join the given strings with the given delimiter.\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.repeat.adoc[apoc.text.repeat(\u0026lsquo;item\u0026rsquo;,count)] | multiply the given string with the given count\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.format.adoc[apoc.text.format(text,[params],language)] | sprintf format the string with the params given, and optional param language (default value is \u0026lsquo;en\u0026rsquo;).\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.lpad.adoc[apoc.text.lpad(text,count,delim)] | left pad the string to the given width\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.rpad.adoc[apoc.text.rpad(text,count,delim)] | right pad the string to the given width\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.random.adoc[apoc.text.random(length, [valid])] | returns a random string to the specified length\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.capitalize.adoc[apoc.text.capitalize(text)] | capitalise the first letter of the word\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.capitalizeAll.adoc[apoc.text.capitalizeAll(text)] | capitalise the first letter of every word in the text\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.decapitalize.adoc[apoc.text.decapitalize(text)] | decapitalize the first letter of the word\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.decapitalizeAll.adoc[apoc.text.decapitalizeAll(text)] | decapitalize the first letter of all words\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.swapCase.adoc[apoc.text.swapCase(text)] | Swap the case of a string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.camelCase.adoc[apoc.text.camelCase(text)] | Convert a string to camelCase\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.upperCamelCase.adoc[apoc.text.upperCamelCase(text)] | Convert a string to UpperCamelCase\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.snakeCase.adoc[apoc.text.snakeCase(text)] | Convert a string to snake-case\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.toUpperCase.adoc[apoc.text.toUpperCase(text)] | Convert a string to UPPER_CASE\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.charAt.adoc[apoc.text.charAt(text, index)] | Returns the decimal value of the character at the given index\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.code.adoc[apoc.text.code(codepoint)] | Returns the unicode character of the given codepoint\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.hexCharAt.adoc[apoc.text.hexCharAt(text, index)] | Returns the hex value string of the character at the given index\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.hexValue.adoc[apoc.text.hexValue(value)] | Returns the hex value string of the given value\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.byteCount.adoc[+++apoc.text.byteCount(text,[charset])+++] | return size of text in bytes\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.bytes.adoc[+++apoc.text.bytes(text,[charset])+++] | return bytes of the text\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.toCypher.adoc[apoc.text.toCypher(value, {skipKeys,keepKeys,skipValues,keepValues,skipNull,node,relationship,start,end})] | tries its best to convert the value to a cypher-property-string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64Encode.adoc[apoc.text.base64Encode(text)] | Encode a string with Base64\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64Decode.adoc[apoc.text.base64Decode(text)] | Decode Base64 encoded string\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64UrlEncode.adoc[apoc.text.base64UrlEncode(url)] | Encode a url with Base64\u003cbr /\u003e\n| xref::overview/apoc.text/apoc.text.base64UrlDecode.adoc[apoc.text.base64UrlDecode(url)] | Decode Base64 encoded url\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003ereplace\u003c/code\u003e, \u003ccode\u003esplit\u003c/code\u003e and \u003ccode\u003eregexGroups\u003c/code\u003e functions work with regular expressions.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-data-extraction\"\u003etext-functions-data-extraction\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Data Extraction\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.data.url(\u0026lsquo;url\u0026rsquo;) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\u003cbr /\u003e\n| apoc.data.email(\u0026lsquo;email_address\u0026rsquo;) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\u003cbr /\u003e\n| apoc.data.domain(email_or_url) | \u003cem\u003edeprecated\u003c/em\u003e returns domain part of the value\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-text-similarity\"\u003etext-functions-text-similarity\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Text Similarity Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\u003cbr /\u003e\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\u003cbr /\u003e\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\u003cbr /\u003e\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u0026lt; 3 then 0, length \u0026lt; 5 then 1, else 2).\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\nThe replace, split and regexGroups functions work with regular expressions.\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Data extraction\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Text Similarity\u003c/p\u003e\n\u003cp\u003e// useful to data clean purpose\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.distance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinDistance(text1, text2) | compare the given strings with the Levenshtein distance algorithm\u003cbr /\u003e\n| apoc.text.levenshteinSimilarity(text1, text2) | calculate the similarity (a value within 0 and 1) between two texts based on Levenshtein distance.\u003cbr /\u003e\n| apoc.text.hammingDistance(text1, text2) | compare the given strings with the Hamming distance algorithm\u003cbr /\u003e\n| apoc.text.jaroWinklerDistance(text1, text2) | compare the given strings with the Jaro-Winkler distance algorithm\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarity(text1, text2) | compare the given strings with the Sørensen–Dice coefficient formula, assuming an English locale\u003cbr /\u003e\n| apoc.text.sorensenDiceSimilarityWithLanguage(text1, text2, languageTag) | compare the given strings with the Sørensen–Dice coefficient formula, with the provided IETF language tag\u003cbr /\u003e\n| apoc.text.fuzzyMatch(text1, text2) | check if 2 words can be matched in a fuzzy way (LevenShtein). Depending on the length of the String it will allow more characters that needs to be edited to match the second String (distance: length \u0026lt; 3 then 0, length \u0026lt; 5 then 1, else 2).\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;HelloWorld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.replace(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;[^a-zA-Z]\u0026rsquo;, \u0027\u0027)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eRETURN apoc.text.regexGroups(\u0026lsquo;abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rsquo;,\u0026lsquo;\u0026lt;link (\\w+)\u0026gt;(\\w+)\u003c/link\u003e\u0026rsquo;) AS result\u003c/p\u003e\n\u003ch2\u003e// [[\u0026ldquo;\u003clink xxx1\u003eyyy1\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx1\u0026rdquo;, \u0026ldquo;yyy1\u0026rdquo;], [\u0026ldquo;\u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx2\u0026rdquo;, \u0026ldquo;yyy2\u0026rdquo;]]\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d\u003d Compare the  strings with the Levenshtein distance\u003c/p\u003e\n\u003cp\u003eCompare the given strings with the \u003ccode\u003eStringUtils.distance(text1, text2)\u003c/code\u003e method (Levenshtein).\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.distance(\u0026ldquo;Levenshtein\u0026rdquo;, \u0026ldquo;Levenstein\u0026rdquo;) // 1\u003c/h2\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.data.url(\u0026lsquo;url\u0026rsquo;) as {protocol,user,host,port,path,query,file,anchor} | turn URL into map structure\u003cbr /\u003e\n| apoc.data.email(\u0026lsquo;email_address\u0026rsquo;) as {personal,user,domain} | extract the personal name, user and domain as a map (needs javax.mail jar)\u003cbr /\u003e\n| apoc.data.domain(email_or_url) | \u003cem\u003edeprecated\u003c/em\u003e returns domain part of the value\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-phonetic-comparison\"\u003etext-functions-phonetic-comparison\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Phonetic Comparison Functions\u003c/p\u003e\n\u003cp\u003eThe phonetic text (soundex) functions allow you to compute the soundex encoding of a given string.\u003cbr /\u003e\nThere is also a procedure to compare how similar two strings sound under the soundex algorithm.\u003cbr /\u003e\nAll soundex procedures by default assume the used language is US English.\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.phonetic(value) | Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings\u003cbr /\u003e\n| apoc.text.doubleMetaphone(value) | Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings\u003cbr /\u003e\n| apoc.text.clean(text) | strip the given string of everything except alpha numeric characters and convert it to lower case.\u003cbr /\u003e\n| apoc.text.compareCleaned(text1, text2) | compare the given strings stripped of everything except alpha numeric characters converted to lower case.\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e.Procedure\u003cbr /\u003e\n[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta | Compute the US_ENGLISH soundex character difference between two given strings\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003e// will return \u0026lsquo;H436\u0026rsquo;\u003cbr /\u003e\nRETURN apoc.text.phonetic(\u0026lsquo;Hello, dear User!\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003e// will return \u0026lsquo;4\u0026rsquo;  (very similar)\u003cbr /\u003e\nRETURN apoc.text.phoneticDelta(\u0026lsquo;Hello Mr Rabbit\u0026rsquo;, \u0026lsquo;Hello Mr Ribbit\u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-formatting-text\"\u003etext-functions-formatting-text\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Formatting Text\u003c/p\u003e\n\u003cp\u003eFormat the string with the params given, and optional param language.\u003c/p\u003e\n\u003cp\u003e.without language param (\u0026lsquo;en\u0026rsquo; default)\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.format(\u0026lsquo;ab%s %d %.1f %s%n\u0026rsquo;,[\u0026lsquo;cd\u0026rsquo;,42,3.14,true]) AS value // abcd 42 3.1 true\u003c/h2\u003e\n\u003cp\u003e.with language param\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.format(\u0026lsquo;ab%s %d %.1f %s%n\u0026rsquo;,[\u0026lsquo;cd\u0026rsquo;,42,3.14,true],\u0026lsquo;it\u0026rsquo;) AS value // abcd 42 3,1 true\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-string-search\"\u003etext-functions-string-search\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d String Search\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003eindexOf\u003c/code\u003e function, provides the fist occurrence of the given \u003ccode\u003elookup\u003c/code\u003e string within the \u003ccode\u003etext\u003c/code\u003e, or -1 if not found.\u003cbr /\u003e\nIt can optionally take \u003ccode\u003efrom\u003c/code\u003e (inclusive) and \u003ccode\u003eto\u003c/code\u003e (exclusive) parameters.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.indexOf(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;World\u0026rsquo;) // 6\u003c/h2\u003e\n\u003cp\u003eThe \u003ccode\u003eindexesOf\u003c/code\u003e function, provides all occurrences of the given lookup string within the text, or empty list if not found.\u003cbr /\u003e\nIt can optionally take \u003ccode\u003efrom\u003c/code\u003e (inclusive) and \u003ccode\u003eto\u003c/code\u003e (exclusive) parameters.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.indexesOf(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;o\u0026rsquo;,2,9) // [4,7]\u003c/h2\u003e\n\u003cp\u003eIf you want to get a substring starting from your index match, you can use this\u003c/p\u003e\n\u003ch2\u003e.returns \u003ccode\u003eWorld!\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;Hello World!\u0026rsquo; as text, length(text) as len\u003cbr /\u003e\nWITH text, len, apoc.text.indexOf(text, \u0026lsquo;World\u0026rsquo;,3) as index\u003cbr /\u003e\nRETURN substring(text, case index when -1 then len-1 else index end, len);\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-regex\"\u003etext-functions-regex\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Regular Expressions\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;HelloWorld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.replace(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;[^a-zA-Z]\u0026rsquo;, \u0027\u0027)\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eRETURN apoc.text.regexGroups(\u0026lsquo;abc \u003clink xxx1\u003eyyy1\u003c/link\u003e def \u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rsquo;,\u0026lsquo;\u0026lt;link (\\w+)\u0026gt;(\\w+)\u003c/link\u003e\u0026rsquo;) AS result\u003c/p\u003e\n\u003ch2\u003e// [[\u0026ldquo;\u003clink xxx1\u003eyyy1\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx1\u0026rdquo;, \u0026ldquo;yyy1\u0026rdquo;], [\u0026ldquo;\u003clink xxx2\u003eyyy2\u003c/link\u003e\u0026rdquo;, \u0026ldquo;xxx2\u0026rdquo;, \u0026ldquo;yyy2\u0026rdquo;]]\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-split-join\"\u003etext-functions-split-join\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Split and Join\u003c/p\u003e\n\u003ch2\u003e.will split with the given regular expression return [\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;World\u0026rsquo;]\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.split(\u0026lsquo;Hello   World\u0026rsquo;, \u0026rsquo; +\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return \u0026lsquo;Hello World\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.join([\u0026lsquo;Hello\u0026rsquo;, \u0026lsquo;World\u0026rsquo;], \u0026rsquo; \u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-data-cleaning\"\u003etext-functions-data-cleaning\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Data Cleaning\u003c/p\u003e\n\u003ch2\u003e.will return \u0026lsquo;helloworld\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.clean(\u0026lsquo;Hello World!\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return \u003ccode\u003etrue\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.compareCleaned(\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;\u003cem\u003ehello-world\u003c/em\u003e\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.will return only \u0026lsquo;Hello World!\u0026rsquo;\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eUNWIND [\u0026lsquo;Hello World!\u0026rsquo;, \u0026lsquo;hello worlds\u0026rsquo;] as text\u003cbr /\u003e\nRETURN apoc.text.filterCleanMatches(text, \u0026lsquo;hello_world\u0026rsquo;) as text\u003c/h2\u003e\n\u003cp\u003eThe clean functionality can be useful for cleaning up slightly dirty text data with inconsistent formatting for non-exact comparisons.\u003c/p\u003e\n\u003cp\u003eCleaning will strip the string of all non-alphanumeric characters (including spaces) and convert it to lower case.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-case-change\"\u003etext-functions-case-change\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Case Change Functions\u003c/p\u003e\n\u003ch2\u003e.Capitalise the first letter of the word with \u003ccode\u003ecapitalize\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.capitalize(\u0026ldquo;neo4j\u0026rdquo;) // \u0026ldquo;Neo4j\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Capitalise the first letter of every word in the text with \u003ccode\u003ecapitalizeAll\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.capitalizeAll(\u0026ldquo;graph database\u0026rdquo;) // \u0026ldquo;Graph Database\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Decapitalize the first letter of the string with \u003ccode\u003edecapitalize\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.decapitalize(\u0026ldquo;Graph Database\u0026rdquo;) // \u0026ldquo;graph Database\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Decapitalize the first letter of all words with \u003ccode\u003edecapitalizeAll\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.decapitalizeAll(\u0026ldquo;Graph Databases\u0026rdquo;) // \u0026ldquo;graph databases\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Swap the case of a string with \u003ccode\u003eswapCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.swapCase(\u0026ldquo;Neo4j\u0026rdquo;) // nEO4J\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to lower camelCase with \u003ccode\u003ecamelCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.camelCase(\u0026ldquo;FOO_BAR\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo bar\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo22 bar\u0026rdquo;);  // \u0026ldquo;foo22Bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;foo-bar\u0026rdquo;);    // \u0026ldquo;fooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foobar\u0026rdquo;);     // \u0026ldquo;foobar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.camelCase(\u0026ldquo;Foo$$Bar\u0026rdquo;);   // \u0026ldquo;fooBar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to UpperCamelCase with \u003ccode\u003eupperCamelCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.upperCamelCase(\u0026ldquo;FOO_BAR\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo bar\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo22 bar\u0026rdquo;); // \u0026ldquo;Foo22Bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;foo-bar\u0026rdquo;);   // \u0026ldquo;FooBar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foobar\u0026rdquo;);    // \u0026ldquo;Foobar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.upperCamelCase(\u0026ldquo;Foo$$Bar\u0026rdquo;);  // \u0026ldquo;FooBar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to snake-case with \u003ccode\u003esnakeCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.snakeCase(\u0026ldquo;test Snake Case\u0026rdquo;); // \u0026ldquo;test-snake-case\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;FOO_BAR\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;fooBar\u0026rdquo;);          // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;foo-bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo bar\u0026rdquo;);         // \u0026ldquo;foo-bar\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.snakeCase(\u0026ldquo;Foo  bar\u0026rdquo;);        // \u0026ldquo;foo-bar\u0026rdquo;\u003c/h2\u003e\n\u003ch2\u003e.Convert a string to UPPER_CASE with \u003ccode\u003etoUpperCase\u003c/code\u003e\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.toUpperCase(\u0026ldquo;test upper case\u0026rdquo;); // \u0026ldquo;TEST_UPPER_CASE\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;FooBar\u0026rdquo;);          // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;fooBar\u0026rdquo;);          // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo-bar\u0026rdquo;);         // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo\u0026ndash;bar\u0026rdquo;);        // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo$$bar\u0026rdquo;);        // \u0026ldquo;FOO_BAR\u0026rdquo;\u003cbr /\u003e\nRETURN apoc.text.toUpperCase(\u0026ldquo;foo 22 bar\u0026rdquo;);      // \u0026ldquo;FOO_22_BAR\u0026rdquo;\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-base64-encoding-decoding\"\u003etext-functions-base64-encoding-decoding\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Base64 De- and Encoding\u003c/p\u003e\n\u003cp\u003eEncode or decode a string in base64 or base64Url\u003c/p\u003e\n\u003ch2\u003e.Encode base 64\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64Encode(\u0026ldquo;neo4j\u0026rdquo;) // bmVvNGo\u003d\u003c/h2\u003e\n\u003ch2\u003e.Decode base 64\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64Decode(\u0026ldquo;bmVvNGo\u003d\u0026rdquo;) // neo4j\u003c/h2\u003e\n\u003ch2\u003e.Encode base 64 URL\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64UrlEncode(\u0026ldquo;\u003ca href\u003d\"http://neo4j.com/?test\u003dtest\"\u003ehttp://neo4j.com/?test\u003dtest\u003c/a\u003e\u0026rdquo;) // aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\u003c/h2\u003e\n\u003ch2\u003e.Decode base 64 URL\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.base64UrlDecode(\u0026ldquo;aHR0cDovL25lbzRqLmNvbS8_dGVzdD10ZXN0\u0026rdquo;) // \u003ca href\u003d\"http://neo4j.com/?test\u003dtest\"\u003ehttp://neo4j.com/?test\u003dtest\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-random-string\"\u003etext-functions-random-string\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Random String\u003c/p\u003e\n\u003cp\u003eYou can generate a random string to a specified length by calling \u003ccode\u003eapoc.text.random\u003c/code\u003e with a length parameter and optional string of valid characters.\u003c/p\u003e\n\u003cp\u003eThe \u003ccode\u003evalid\u003c/code\u003e parameter will accept the following regex patterns, alternatively you can provide a string of letters and/or characters.\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| Pattern | Description\u003cbr /\u003e\n| A-Z | A-Z in uppercase\u003cbr /\u003e\n| a-z | A-Z in lowercase\u003cbr /\u003e\n| 0-9 | Numbers 0-9 inclusive\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.The following call will return a random string including uppercase letters, numbers and \u003ccode\u003e.\u003c/code\u003e and \u003ccode\u003e$\u003c/code\u003e characters.\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.text.random(10, \u0026ldquo;A-Z0-9.$\u0026rdquo;)\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-extract-domain\"\u003etext-functions-extract-domain\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Extract Domain\u003c/p\u003e\n\u003cp\u003eThe User Function \u003ccode\u003eapoc.data.domain\u003c/code\u003e will take a url or email address and try to determine the domain name.\u003cbr /\u003e\nThis can be useful to make easier correlations and equality tests between differently formatted email addresses, and between urls to the same domains but specifying different locations.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;\u003ca href\u003d\"mailto:foo@bar.com\"\u003efoo@bar.com\u003c/a\u003e\u0026rsquo; AS email\u003cbr /\u003e\nRETURN apoc.data.domain(email) // will return \u0026lsquo;bar.com\u0026rsquo;\u003c/h2\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH \u0026lsquo;\u003ca href\u003d\"http://www.example.com/all-the-things\"\u003ehttp://www.example.com/all-the-things\u003c/a\u003e\u0026rsquo; AS url\u003cbr /\u003e\nRETURN apoc.data.domain(url) // will return \u0026lsquo;\u003ca href\u003d\"http://www.example.com\"\u003ewww.example.com\u003c/a\u003e\u0026rsquo;\u003c/h2\u003e\n\u003cp\u003e\u003ca href\u003d\"text-functions-hashing\"\u003etext-functions-hashing\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Hashing Functions\u003c/p\u003e\n\u003cp\u003e[cols\u003d\u0026ldquo;5m,5\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| apoc.util.sha1([values]) | computes the sha1 of the concatenation of all string values of the list\u003cbr /\u003e\n| apoc.util.md5([values]) | computes the md5 of the concatenation of all string values of the list\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349483128_1944019862",
      "id": "paragraph_1635349483128_1944019862",
      "dateCreated": "2021-10-27 15:44:43.128",
      "dateStarted": "2021-10-29 12:08:52.746",
      "dateFinished": "2021-10-29 12:08:52.911",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d Spatial\n\nThe spatial procedures enable geographic capabilities on your data, and complement the https://neo4j.com/docs/cypher-manual/current/functions/spatial/[spatial functions^] that come with Neo4j.\nMore extensive Spatial functionality can be found in the https://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html[Neo4j Spatial Library^].\n\n[separator\u003d¦,opts\u003dheader,cols\u003d\"5,1m,1m\"]\n|\u003d\u003d\u003d\n¦Qualified Name¦Type¦Release\ninclude::example$generated-documentation/apoc.spatial.geocode.adoc[]\ninclude::example$generated-documentation/apoc.spatial.reverseGeocode.adoc[]\ninclude::example$generated-documentation/apoc.spatial.sortByDistance.adoc[]\n|\u003d\u003d\u003d\n\n\n\u003d\u003d Geocode\n\nThe _geocode_ procedure converts a textual address into a location containing _latitude_, _longitude_ and _description_.\nDespite being only a single function, together with the built-in functions _point_ and _distance_ we can achieve quite powerful results.\n\nFirst, how can we use the procedure:\n\n[source,cypher]\n----\nCALL apoc.spatial.geocodeOnce(\u002721 rue Paul Bellamy 44000 NANTES FRANCE\u0027)\nYIELD location\nRETURN location.latitude, location.longitude\n----\n\n.Results\n[opts\u003d\"header\"]\n|\u003d\u003d\u003d\n| location.latitude | location.longitude\n| 47.2221667 | -1.5566625\n|\u003d\u003d\u003d\n\n\nThere are three forms of the procedure:\n\n* geocodeOnce(address) returns zero or one result.\n* geocode(address,maxResults) returns zero, one or more up to maxResults.\n* reverseGeocode(latitude,longitude) returns zero or one result.\n\nThis is because the backing geocoding service (OSM, Google, OpenCage or other) might return multiple results for the same query.\nGeocodeOnce() is designed to return the first, or highest ranking result.\n\nThe third procedure _reverseGeocode_ will convert a location containing _latitude_ and _longitude_ into a textual address.\n\n[source,cypher]\n----\nCALL apoc.spatial.reverseGeocode(47.2221667,-1.5566625) YIELD location\nRETURN location.description;\n----\n\n.Results\n[opts\u003d\"header\"]\n|\u003d\u003d\u003d\n| location.description\n| \"21, Rue Paul Bellamy, Talensac - Pont Morand, Hauts-Pavés - Saint-Félix, Nantes, Loire-Atlantique, Pays de la Loire, France métropolitaine, 44000, France\"\n|\u003d\u003d\u003d\n\n\u003d\u003d\u003d Configuring Geocode\n\nThere are a few options that can be set in the apoc.conf file to control the service:\n\n* apoc.spatial.geocode.provider\u003dosm (osm, google, opencage, etc.)\n* apoc.spatial.geocode.osm.throttle\u003d5000 (ms to delay between queries to not overload OSM servers)\n* apoc.spatial.geocode.google.throttle\u003d1 (ms to delay between queries to not overload Google servers)\n* apoc.spatial.geocode.google.key\u003dxxxx (API key for google geocode access)\n* apoc.spatial.geocode.google.client\u003dxxxx (client code for google geocode access)\n* apoc.spatial.geocode.google.signature\u003dxxxx (client signature for google geocode access)\n\nFor google, you should use either a key or a combination of client and signature. Read more\nabout this on the google page for geocode access at\nhttps://developers.google.com/maps/documentation/geocoding/get-api-key#key\n\n\u003d\u003d\u003d Configuring Custom Geocode Provider\n\n*Geocode*\n\nFor any provider that is not \u0027osm\u0027 or \u0027google\u0027 you get a configurable supplier that requires two\nadditional settings, \u0027url\u0027 and \u0027key\u0027. The \u0027url\u0027 must contain the two words \u0027PLACE\u0027 and \u0027KEY\u0027.\nThe \u0027KEY\u0027 will be replaced with the key you get from the provider when you register for the service.\nThe \u0027PLACE\u0027 will be replaced with the address to geocode when the procedure is called.\n\n*Reverse Geocode*\n\nThe \u0027url\u0027 must contain the three words \u0027LAT\u0027, \u0027LNG\u0027 and \u0027KEY\u0027.\nThe \u0027LAT\u0027 will be replaced with the latitude and \u0027LNG\u0027 will be replaced with the the longitude to reverse geocode when the procedure is called.\n\nFor example, to get the service working with OpenCage, perform the following steps:\n\n* Register your own application key at https://geocoder.opencagedata.com/\n* Once you have a key, add the following three lines to apoc.conf\n\n----\napoc.spatial.geocode.provider\u003dopencage\napoc.spatial.geocode.opencage.key\u003dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\napoc.spatial.geocode.opencage.url\u003dhttp://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026key\u003dKEY\napoc.spatial.geocode.opencage.reverse.url\u003dhttp://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026key\u003dKEY\n----\n\n* make sure that the \u0027XXXXXXX\u0027 part above is replaced with your actual key\n* Restart the Neo4j server and then test the geocode procedures to see that they work\n* If you are unsure if the provider is correctly configured try verify with:\n\n\n\n[source,cypher]\n----\nCALL apoc.spatial.showConfig()\n----\n\n\u003d\u003d Using Geocode within a bigger Cypher query\n\nA more complex, or useful, example which geocodes addresses found in properties of nodes:\n\n[source,cypher]\n----\nMATCH (a:Place)\nWHERE exists(a.address)\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nRETURN location.latitude AS latitude, location.longitude AS longitude, location.description AS description\n----\n\n\u003d\u003d Calculating distance between locations\n\nIf we wish to calculate the distance between addresses, we need to use the point() function to convert\nlatitude and longitude to Cyper Point types, and then use the distance() function to calculate the distance:\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (a:Place)\nWHERE exists(a.address)\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nWITH location, distance(point(location), eiffel) AS distance\nWHERE distance \u003c 5000\nRETURN location.description AS description, distance\nORDER BY distance\nLIMIT 100\n----\n\n\u003d\u003d\u003d sortByDistance\n\nThe second procedure enables you to sort a given collection of paths by the sum of their distance based on lat/long properties\non the nodes.\n\nSample data :\n\n[source, cypher]\n----\nCREATE (bruges:City {name:\"bruges\", latitude: 51.2605829, longitude: 3.0817189})\nCREATE (brussels:City {name:\"brussels\", latitude: 50.854954, longitude: 4.3051786})\nCREATE (paris:City {name:\"paris\", latitude: 48.8588376, longitude: 2.2773455})\nCREATE (dresden:City {name:\"dresden\", latitude: 51.0767496, longitude: 13.6321595})\nMERGE (bruges)-[:NEXT]-\u003e(brussels)\nMERGE (brussels)-[:NEXT]-\u003e(dresden)\nMERGE (brussels)-[:NEXT]-\u003e(paris)\nMERGE (bruges)-[:NEXT]-\u003e(paris)\nMERGE (paris)-[:NEXT]-\u003e(dresden)\n----\n\nFinding paths and sort them by distance\n\n[source, cypher]\n----\nMATCH (a:City {name:\u0027bruges\u0027}), (b:City {name:\u0027dresden\u0027})\nMATCH p\u003d(a)-[*]-\u003e(b)\nWITH collect(p) as paths\nCALL apoc.spatial.sortByDistance(paths) YIELD path, distance\nRETURN path, distance\n----\n\n\u003d\u003d Graph Refactoring\n\nIn order not to have to repeatedly geocode the same thing in multiple queries, especially\nif the database will be used by many people, it might be a good idea to persist the results\nin the database so that subsequent calls can use the saved results.\n\nGeocode and persist the result\n\n[source,cypher]\n----\nMATCH (a:Place)\nWHERE exists(a.address) AND NOT exists(a.latitude)\nWITH a LIMIT 1000\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\nSET a.latitude \u003d location.latitude\nSET a.longitude \u003d location.longitude\n----\n\nNote that the above command only geocodes the first 1000 ‘Place’ nodes that have not already been geocoded.\nThis query can be run multiple times until all places are geocoded. Why would we want to do this?\nTwo good reasons:\n\n* The geocoding service is a public service that can throttle or blacklist sites that hit the service too heavily, so controlling how much we do is useful.\n* The transaction is updating the database, and it is wise not to update the database with too many things in the same transaction, to avoid using up too much memory. This trick will keep the memory usage very low.\n\nNow make use of the results in distance queries\n\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (a:Place)\nWHERE exists(a.latitude) AND exists(a.longitude)\nWITH a, distance(point(a), eiffel) AS distance\nWHERE distance \u003c 5000\nRETURN a.name, distance\nORDER BY distance\nLIMIT 100\n----\n\n\u003d\u003d Combined Space and Time search\n\nCombining spatial and date-time functions can allow for more complex queries:\n\n[source,cypher]\n----\nWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\nMATCH (e:Event)\nWHERE exists(e.address) AND exists(e.datetime)\nCALL apoc.spatial.geocodeOnce(e.address) YIELD location\nWITH e, location,\ndistance(point(location), eiffel) AS distance,\n            (apoc.date.parse(\u00272016-06-01 00:00:00\u0027,\u0027h\u0027) - apoc.date.parse(e.datetime,\u0027h\u0027))/24.0 AS days_before_due\nWHERE distance \u003c 5000 AND days_before_due \u003c 14 AND apoc.date.parse(e.datetime,\u0027h\u0027) \u003c apoc.date.parse(\u00272016-06-01 00:00:00\u0027,\u0027h\u0027)\nRETURN e.name AS event, e.datetime AS date,\nlocation.description AS description, distance\nORDER BY distance\n----\n\nWith date parse we can parse any type of string date to date\n```\nWITH apoc.date.parse(\"31/05/2019\", \"ms\", \"dd/MM/yyyy\") AS ms\nRETURN date(datetime({epochmillis: ms})) AS date\n```\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:15:07.611",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Spatial\u003c/p\u003e\n\u003cp\u003eThe spatial procedures enable geographic capabilities on your data, and complement the \u003ca href\u003d\"https://neo4j.com/docs/cypher-manual/current/functions/spatial/\"\u003ehttps://neo4j.com/docs/cypher-manual/current/functions/spatial/\u003c/a\u003e[spatial functions^] that come with Neo4j.\u003cbr /\u003e\nMore extensive Spatial functionality can be found in the \u003ca href\u003d\"https://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html\"\u003ehttps://neo4j-contrib.github.io/spatial/0.24-neo4j-3.1/index.html\u003c/a\u003e[Neo4j Spatial Library^].\u003c/p\u003e\n\u003cp\u003e[separator\u003d¦,opts\u003dheader,cols\u003d\u0026ldquo;5,1m,1m\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n¦Qualified Name¦Type¦Release\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.geocode.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.reverseGeocode.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.spatial.sortByDistance.adoc[]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Geocode\u003c/p\u003e\n\u003cp\u003eThe \u003cem\u003egeocode\u003c/em\u003e procedure converts a textual address into a location containing \u003cem\u003elatitude\u003c/em\u003e, \u003cem\u003elongitude\u003c/em\u003e and \u003cem\u003edescription\u003c/em\u003e.\u003cbr /\u003e\nDespite being only a single function, together with the built-in functions \u003cem\u003epoint\u003c/em\u003e and \u003cem\u003edistance\u003c/em\u003e we can achieve quite powerful results.\u003c/p\u003e\n\u003cp\u003eFirst, how can we use the procedure:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.geocodeOnce(\u0026lsquo;21 rue Paul Bellamy 44000 NANTES FRANCE\u0026rsquo;)\u003cbr /\u003e\nYIELD location\u003cbr /\u003e\nRETURN location.latitude, location.longitude\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| location.latitude | location.longitude\u003cbr /\u003e\n| 47.2221667 | -1.5566625\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThere are three forms of the procedure:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003egeocodeOnce(address) returns zero or one result.\u003c/li\u003e\n\u003cli\u003egeocode(address,maxResults) returns zero, one or more up to maxResults.\u003c/li\u003e\n\u003cli\u003ereverseGeocode(latitude,longitude) returns zero or one result.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThis is because the backing geocoding service (OSM, Google, OpenCage or other) might return multiple results for the same query.\u003cbr /\u003e\nGeocodeOnce() is designed to return the first, or highest ranking result.\u003c/p\u003e\n\u003cp\u003eThe third procedure \u003cem\u003ereverseGeocode\u003c/em\u003e will convert a location containing \u003cem\u003elatitude\u003c/em\u003e and \u003cem\u003elongitude\u003c/em\u003e into a textual address.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.reverseGeocode(47.2221667,-1.5566625) YIELD location\u003cbr /\u003e\nRETURN location.description;\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| location.description\u003cbr /\u003e\n| \u0026ldquo;21, Rue Paul Bellamy, Talensac - Pont Morand, Hauts-Pavés - Saint-Félix, Nantes, Loire-Atlantique, Pays de la Loire, France métropolitaine, 44000, France\u0026rdquo;\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Configuring Geocode\u003c/p\u003e\n\u003cp\u003eThere are a few options that can be set in the apoc.conf file to control the service:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eapoc.spatial.geocode.provider\u003dosm (osm, google, opencage, etc.)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.osm.throttle\u003d5000 (ms to delay between queries to not overload OSM servers)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.throttle\u003d1 (ms to delay between queries to not overload Google servers)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.key\u003dxxxx (API key for google geocode access)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.client\u003dxxxx (client code for google geocode access)\u003c/li\u003e\n\u003cli\u003eapoc.spatial.geocode.google.signature\u003dxxxx (client signature for google geocode access)\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eFor google, you should use either a key or a combination of client and signature. Read more\u003cbr /\u003e\nabout this on the google page for geocode access at\u003cbr /\u003e\n\u003ca href\u003d\"https://developers.google.com/maps/documentation/geocoding/get-api-key#key\"\u003ehttps://developers.google.com/maps/documentation/geocoding/get-api-key#key\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Configuring Custom Geocode Provider\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eGeocode\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eFor any provider that is not \u0026lsquo;osm\u0026rsquo; or \u0026lsquo;google\u0026rsquo; you get a configurable supplier that requires two\u003cbr /\u003e\nadditional settings, \u0026lsquo;url\u0026rsquo; and \u0026lsquo;key\u0026rsquo;. The \u0026lsquo;url\u0026rsquo; must contain the two words \u0026lsquo;PLACE\u0026rsquo; and \u0026lsquo;KEY\u0026rsquo;.\u003cbr /\u003e\nThe \u0026lsquo;KEY\u0026rsquo; will be replaced with the key you get from the provider when you register for the service.\u003cbr /\u003e\nThe \u0026lsquo;PLACE\u0026rsquo; will be replaced with the address to geocode when the procedure is called.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eReverse Geocode\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003eThe \u0026lsquo;url\u0026rsquo; must contain the three words \u0026lsquo;LAT\u0026rsquo;, \u0026lsquo;LNG\u0026rsquo; and \u0026lsquo;KEY\u0026rsquo;.\u003cbr /\u003e\nThe \u0026lsquo;LAT\u0026rsquo; will be replaced with the latitude and \u0026lsquo;LNG\u0026rsquo; will be replaced with the the longitude to reverse geocode when the procedure is called.\u003c/p\u003e\n\u003cp\u003eFor example, to get the service working with OpenCage, perform the following steps:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eRegister your own application key at \u003ca href\u003d\"https://geocoder.opencagedata.com/\"\u003ehttps://geocoder.opencagedata.com/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eOnce you have a key, add the following three lines to apoc.conf\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr /\u003e\n\u003ch2\u003eapoc.spatial.geocode.provider\u003dopencage\u003cbr /\u003e\napoc.spatial.geocode.opencage.key\u003dXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\u003cbr /\u003e\napoc.spatial.geocode.opencage.url\u003d\u003ca href\u003d\"http://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026amp;key\u003dKEY\"\u003ehttp://api.opencagedata.com/geocode/v1/json?q\u003dPLACE\u0026amp;key\u003dKEY\u003c/a\u003e\u003cbr /\u003e\napoc.spatial.geocode.opencage.reverse.url\u003d\u003ca href\u003d\"http://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026amp;key\u003dKEY\"\u003ehttp://api.opencagedata.com/geocode/v1/json?q\u003dLAT+LNG\u0026amp;key\u003dKEY\u003c/a\u003e\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003emake sure that the \u0026lsquo;XXXXXXX\u0026rsquo; part above is replaced with your actual key\u003c/li\u003e\n\u003cli\u003eRestart the Neo4j server and then test the geocode procedures to see that they work\u003c/li\u003e\n\u003cli\u003eIf you are unsure if the provider is correctly configured try verify with:\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.spatial.showConfig()\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Using Geocode within a bigger Cypher query\u003c/p\u003e\n\u003cp\u003eA more complex, or useful, example which geocodes addresses found in properties of nodes:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nRETURN location.latitude AS latitude, location.longitude AS longitude, location.description AS description\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Calculating distance between locations\u003c/p\u003e\n\u003cp\u003eIf we wish to calculate the distance between addresses, we need to use the point() function to convert\u003cbr /\u003e\nlatitude and longitude to Cyper Point types, and then use the distance() function to calculate the distance:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nWITH location, distance(point(location), eiffel) AS distance\u003cbr /\u003e\nWHERE distance \u0026lt; 5000\u003cbr /\u003e\nRETURN location.description AS description, distance\u003cbr /\u003e\nORDER BY distance\u003cbr /\u003e\nLIMIT 100\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d\u003d sortByDistance\u003c/p\u003e\n\u003cp\u003eThe second procedure enables you to sort a given collection of paths by the sum of their distance based on lat/long properties\u003cbr /\u003e\non the nodes.\u003c/p\u003e\n\u003cp\u003eSample data :\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCREATE (bruges:City {name:\u0026ldquo;bruges\u0026rdquo;, latitude: 51.2605829, longitude: 3.0817189})\u003cbr /\u003e\nCREATE (brussels:City {name:\u0026ldquo;brussels\u0026rdquo;, latitude: 50.854954, longitude: 4.3051786})\u003cbr /\u003e\nCREATE (paris:City {name:\u0026ldquo;paris\u0026rdquo;, latitude: 48.8588376, longitude: 2.2773455})\u003cbr /\u003e\nCREATE (dresden:City {name:\u0026ldquo;dresden\u0026rdquo;, latitude: 51.0767496, longitude: 13.6321595})\u003cbr /\u003e\nMERGE (bruges)-[:NEXT]-\u0026gt;(brussels)\u003cbr /\u003e\nMERGE (brussels)-[:NEXT]-\u0026gt;(dresden)\u003cbr /\u003e\nMERGE (brussels)-[:NEXT]-\u0026gt;(paris)\u003cbr /\u003e\nMERGE (bruges)-[:NEXT]-\u0026gt;(paris)\u003cbr /\u003e\nMERGE (paris)-[:NEXT]-\u0026gt;(dresden)\u003c/h2\u003e\n\u003cp\u003eFinding paths and sort them by distance\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:City {name:\u0026lsquo;bruges\u0026rsquo;}), (b:City {name:\u0026lsquo;dresden\u0026rsquo;})\u003cbr /\u003e\nMATCH p\u003d(a)-[*]-\u0026gt;(b)\u003cbr /\u003e\nWITH collect(p) as paths\u003cbr /\u003e\nCALL apoc.spatial.sortByDistance(paths) YIELD path, distance\u003cbr /\u003e\nRETURN path, distance\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Graph Refactoring\u003c/p\u003e\n\u003cp\u003eIn order not to have to repeatedly geocode the same thing in multiple queries, especially\u003cbr /\u003e\nif the database will be used by many people, it might be a good idea to persist the results\u003cbr /\u003e\nin the database so that subsequent calls can use the saved results.\u003c/p\u003e\n\u003cp\u003eGeocode and persist the result\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.address) AND NOT exists(a.latitude)\u003cbr /\u003e\nWITH a LIMIT 1000\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(a.address) YIELD location\u003cbr /\u003e\nSET a.latitude \u003d location.latitude\u003cbr /\u003e\nSET a.longitude \u003d location.longitude\u003c/h2\u003e\n\u003cp\u003eNote that the above command only geocodes the first 1000 ‘Place’ nodes that have not already been geocoded.\u003cbr /\u003e\nThis query can be run multiple times until all places are geocoded. Why would we want to do this?\u003cbr /\u003e\nTwo good reasons:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eThe geocoding service is a public service that can throttle or blacklist sites that hit the service too heavily, so controlling how much we do is useful.\u003c/li\u003e\n\u003cli\u003eThe transaction is updating the database, and it is wise not to update the database with too many things in the same transaction, to avoid using up too much memory. This trick will keep the memory usage very low.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNow make use of the results in distance queries\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (a:Place)\u003cbr /\u003e\nWHERE exists(a.latitude) AND exists(a.longitude)\u003cbr /\u003e\nWITH a, distance(point(a), eiffel) AS distance\u003cbr /\u003e\nWHERE distance \u0026lt; 5000\u003cbr /\u003e\nRETURN a.name, distance\u003cbr /\u003e\nORDER BY distance\u003cbr /\u003e\nLIMIT 100\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Combined Space and Time search\u003c/p\u003e\n\u003cp\u003eCombining spatial and date-time functions can allow for more complex queries:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH point({latitude: 48.8582532, longitude: 2.294287}) AS eiffel\u003cbr /\u003e\nMATCH (e:Event)\u003cbr /\u003e\nWHERE exists(e.address) AND exists(e.datetime)\u003cbr /\u003e\nCALL apoc.spatial.geocodeOnce(e.address) YIELD location\u003cbr /\u003e\nWITH e, location,\u003cbr /\u003e\ndistance(point(location), eiffel) AS distance,\u003cbr /\u003e\n(apoc.date.parse(\u0026lsquo;2016-06-01 00:00:00\u0026rsquo;,\u0026lsquo;h\u0026rsquo;) - apoc.date.parse(e.datetime,\u0026lsquo;h\u0026rsquo;))/24.0 AS days_before_due\u003cbr /\u003e\nWHERE distance \u0026lt; 5000 AND days_before_due \u0026lt; 14 AND apoc.date.parse(e.datetime,\u0026lsquo;h\u0026rsquo;) \u0026lt; apoc.date.parse(\u0026lsquo;2016-06-01 00:00:00\u0026rsquo;,\u0026lsquo;h\u0026rsquo;)\u003cbr /\u003e\nRETURN e.name AS event, e.datetime AS date,\u003cbr /\u003e\nlocation.description AS description, distance\u003cbr /\u003e\nORDER BY distance\u003c/h2\u003e\n\u003cp\u003eWith date parse we can parse any type of string date to date\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eWITH apoc.date.parse(\u0026quot;31/05/2019\u0026quot;, \u0026quot;ms\u0026quot;, \u0026quot;dd/MM/yyyy\u0026quot;) AS ms\nRETURN date(datetime({epochmillis: ms})) AS date\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349510510_26604918",
      "id": "paragraph_1635349510510_26604918",
      "dateCreated": "2021-10-27 15:45:10.510",
      "dateStarted": "2021-10-29 12:08:52.992",
      "dateFinished": "2021-10-29 12:08:53.039",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n# DATE CONVERSION: APOC Date \u0026 Time Conversion\n\nNeo4j supports date and temporal values, but often, we are dealing with differing date formats between systems or files. These can be difficult to express and translate without a few flexible procedures to handle converting one value formatting to another.\n\nAPOC has several procedures for converting and formatting various date, time, and temporal values. They save valuable time in manually converting values or creating a procedure from scratch! The full list of available procedures is in the APOC documentation.",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.559",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003eDATE CONVERSION: APOC Date \u0026amp; Time Conversion\u003c/h1\u003e\n\u003cp\u003eNeo4j supports date and temporal values, but often, we are dealing with differing date formats between systems or files. These can be difficult to express and translate without a few flexible procedures to handle converting one value formatting to another.\u003c/p\u003e\n\u003cp\u003eAPOC has several procedures for converting and formatting various date, time, and temporal values. They save valuable time in manually converting values or creating a procedure from scratch! The full list of available procedures is in the APOC documentation.\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349592486_1411303387",
      "id": "paragraph_1635349592486_1411303387",
      "dateCreated": "2021-10-27 15:46:32.486",
      "dateStarted": "2021-10-29 12:08:53.110",
      "dateFinished": "2021-10-29 12:08:53.120",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n## Converting dates from Integer to String\n\nThe APOC apoc.date.format() takes an integer value for the date and converts it to a string in the desired format, including a custom one. This is commonly used when translating data from APIs, flat files, or even other databases and moving that data into or out of Neo4j.\n\nFormat: apoc.date.format(12345, [\u0027ms\u0027/\u0027s\u0027], [\u0027yyyy/MM/dd HH:mm:ss\u0027])\n\nThis procedure has 3 parameters -\n\n    the date integer value to convert\n\n    how specific the first parameter is (s for seconds, ms for milliseconds)\n\n    how we want the date string result to look",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.580",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003eConverting dates from Integer to String\u003c/h2\u003e\n\u003cp\u003eThe APOC apoc.date.format() takes an integer value for the date and converts it to a string in the desired format, including a custom one. This is commonly used when translating data from APIs, flat files, or even other databases and moving that data into or out of Neo4j.\u003c/p\u003e\n\u003cp\u003eFormat: apoc.date.format(12345, [\u0026lsquo;ms\u0026rsquo;/\u0026lsquo;s\u0026rsquo;], [\u0026lsquo;yyyy/MM/dd HH:mm:ss\u0026rsquo;])\u003c/p\u003e\n\u003cp\u003eThis procedure has 3 parameters -\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ethe date integer value to convert\n\nhow specific the first parameter is (s for seconds, ms for milliseconds)\n\nhow we want the date string result to look\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409417948_1233797478",
      "id": "paragraph_1635409417948_1233797478",
      "dateCreated": "2021-10-28 08:23:37.948",
      "dateStarted": "2021-10-29 12:08:53.228",
      "dateFinished": "2021-10-29 12:08:53.245",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n## apoc.date.format Example:\n\nOur Northwind data has Customer nodes who hopefully make orders with our business. We probably want to record timestamps when the first contact was sent to the business to see which customers were initially contacted in certain months and which probably made sales in the same year.\n\n[source,cypher]\n----\nWITH 841914000 as dateInt //1996-09-05 09:00 in epoch seconds\nCREATE (c:Customer {companyName: \u0027Island Trading\u0027})\nSET c.firstContact \u003d apoc.date.format(dateInt, \u0027s\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027)\nRETURN c",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.596",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003eapoc.date.format Example:\u003c/h2\u003e\n\u003cp\u003eOur Northwind data has Customer nodes who hopefully make orders with our business. We probably want to record timestamps when the first contact was sent to the business to see which customers were initially contacted in certain months and which probably made sales in the same year.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eWITH 841914000 as dateInt //1996-09-05 09:00 in epoch seconds\u003cbr /\u003e\nCREATE (c:Customer {companyName: \u0026lsquo;Island Trading\u0026rsquo;})\u003cbr /\u003e\nSET c.firstContact \u003d apoc.date.format(dateInt, \u0026lsquo;s\u0026rsquo;, \u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;)\u003cbr /\u003e\nRETURN c\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409429578_1130345971",
      "id": "paragraph_1635409429578_1130345971",
      "dateCreated": "2021-10-28 08:23:49.578",
      "dateStarted": "2021-10-29 12:08:53.344",
      "dateFinished": "2021-10-29 12:08:53.354",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\nIn the example above, we have a date integer in seconds, and we want to update our customer information with that datetime in a human-readable format. To do that, we merge the Customer node and set the firstContact property equal to the converted date (using the procedure).\n\nIn the return, we should see the customer’s node with all its properties and the formatted date!",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.610",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003eIn the example above, we have a date integer in seconds, and we want to update our customer information with that datetime in a human-readable format. To do that, we merge the Customer node and set the firstContact property equal to the converted date (using the procedure).\u003c/p\u003e\n\u003cp\u003eIn the return, we should see the customer’s node with all its properties and the formatted date!\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409449201_163175368",
      "id": "paragraph_1635409449201_163175368",
      "dateCreated": "2021-10-28 08:24:09.202",
      "dateStarted": "2021-10-29 12:08:53.465",
      "dateFinished": "2021-10-29 12:08:53.475",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n## Converting dates from String to Integer\n\nLet us do the reverse of what we just did on the previous slide by converting a string value to an integer with apoc.date.parse(). This is helpful for comparing date strings from and to various formats, most commonly in data import or export.\n\nFormat: apoc.date.parse(\u00272019/03/25 03:15:59\u0027, [\u0027ms\u0027/\u0027s\u0027], [\u0027yyyy/MM/dd HH:mm:ss\u0027])\n\nThe procedure needs 3 parameters -\n\n    the date string that needs converted\n\n    how specific the conversion should be (down to seconds s or milliseconds ms)\n\n    what the format is of the date string (1st parameter)",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.624",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003eConverting dates from String to Integer\u003c/h2\u003e\n\u003cp\u003eLet us do the reverse of what we just did on the previous slide by converting a string value to an integer with apoc.date.parse(). This is helpful for comparing date strings from and to various formats, most commonly in data import or export.\u003c/p\u003e\n\u003cp\u003eFormat: apoc.date.parse(\u0026lsquo;2019/03/25 03:15:59\u0026rsquo;, [\u0026lsquo;ms\u0026rsquo;/\u0026lsquo;s\u0026rsquo;], [\u0026lsquo;yyyy/MM/dd HH:mm:ss\u0026rsquo;])\u003c/p\u003e\n\u003cp\u003eThe procedure needs 3 parameters -\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ethe date string that needs converted\n\nhow specific the conversion should be (down to seconds s or milliseconds ms)\n\nwhat the format is of the date string (1st parameter)\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409454888_1885902767",
      "id": "paragraph_1635409454888_1885902767",
      "dateCreated": "2021-10-28 08:24:14.888",
      "dateStarted": "2021-10-29 12:08:53.580",
      "dateFinished": "2021-10-29 12:08:53.591",
      "status": "FINISHED"
    },
    {
      "text": "%md\n## apoc.date.parse Example:\n\nLet us say that we received a notification from our monitoring system that there was an error in the system at timestamp 882230400, so we need to find out which orders were possibly affected by the error. We can use apoc.date.parse() to convert the string-formatted date in our Northwind data to a timestamp and compare that to the timestamp we have from our error system.\n\nWITH 882230400 as errorTimestamp //1997-12-16 00:00:00.000 in epoch seconds\nMATCH (o:Order)\nWHERE apoc.date.parse(o.orderDate, \u0027s\u0027, \u0027yyyy-MM-dd HH:mm:ss.SSS\u0027) \u003d errorTimestamp\nRETURN o\n\nIn our example, we are given a date integer (epoch time from the error in monitoring system) and want to find the orders that were made on that date. We use MATCH to search for Order nodes where the converted orderDate property (using the procedure) matches the date integer of the error and return the orders that are found.\n\nIn the return, we should see 3 orders that have an order date of 1997-12-16!",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.643",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch2\u003eapoc.date.parse Example:\u003c/h2\u003e\n\u003cp\u003eLet us say that we received a notification from our monitoring system that there was an error in the system at timestamp 882230400, so we need to find out which orders were possibly affected by the error. We can use apoc.date.parse() to convert the string-formatted date in our Northwind data to a timestamp and compare that to the timestamp we have from our error system.\u003c/p\u003e\n\u003cp\u003eWITH 882230400 as errorTimestamp //1997-12-16 00:00:00.000 in epoch seconds\u003cbr /\u003e\nMATCH (o:Order)\u003cbr /\u003e\nWHERE apoc.date.parse(o.orderDate, \u0026lsquo;s\u0026rsquo;, \u0026lsquo;yyyy-MM-dd HH:mm:ss.SSS\u0026rsquo;) \u003d errorTimestamp\u003cbr /\u003e\nRETURN o\u003c/p\u003e\n\u003cp\u003eIn our example, we are given a date integer (epoch time from the error in monitoring system) and want to find the orders that were made on that date. We use MATCH to search for Order nodes where the converted orderDate property (using the procedure) matches the date integer of the error and return the orders that are found.\u003c/p\u003e\n\u003cp\u003eIn the return, we should see 3 orders that have an order date of 1997-12-16!\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409466645_527241096",
      "id": "paragraph_1635409466645_527241096",
      "dateCreated": "2021-10-28 08:24:26.645",
      "dateStarted": "2021-10-29 12:08:53.702",
      "dateFinished": "2021-10-29 12:08:53.712",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d Adding or subtracting units from timestamps\n\nThe marketing department might want to see how well a marketing campaign did to generate sales. The campaign was published at timestamp 891388800, and we need to find out how many sales it generated within the first 30 days running.\n\nWe can use apoc.date.add() to take a point in time of epoch milliseconds (integer) and add or subtract a specified time value to find the desired timestamp.\n\nFormat: apoc.date.add(12345, \u0027ms\u0027, -365, \u0027d\u0027)\n\nThe procedure above contains 4 parameters -\n\n    the date integer for adding or subtracting\n\n    how specific the date integer is (s for seconds, ms for milliseconds)\n\n    the number to add or subtract from the date integer\n\n    the unit type to add or subtract",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.657",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Adding or subtracting units from timestamps\u003c/p\u003e\n\u003cp\u003eThe marketing department might want to see how well a marketing campaign did to generate sales. The campaign was published at timestamp 891388800, and we need to find out how many sales it generated within the first 30 days running.\u003c/p\u003e\n\u003cp\u003eWe can use apoc.date.add() to take a point in time of epoch milliseconds (integer) and add or subtract a specified time value to find the desired timestamp.\u003c/p\u003e\n\u003cp\u003eFormat: apoc.date.add(12345, \u0026lsquo;ms\u0026rsquo;, -365, \u0026lsquo;d\u0026rsquo;)\u003c/p\u003e\n\u003cp\u003eThe procedure above contains 4 parameters -\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ethe date integer for adding or subtracting\n\nhow specific the date integer is (s for seconds, ms for milliseconds)\n\nthe number to add or subtract from the date integer\n\nthe unit type to add or subtract\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409477872_135728276",
      "id": "paragraph_1635409477872_135728276",
      "dateCreated": "2021-10-28 08:24:37.872",
      "dateStarted": "2021-10-29 12:08:53.819",
      "dateFinished": "2021-10-29 12:08:53.828",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\u003d\u003d apoc.date.add Example:\n\nWITH 891388800 as startDate\nWITH startDate, apoc.date.add(startDate, \u0027s\u0027, 30, \u0027d\u0027) as endDate\nMATCH (o:Order)\nWHERE startDate \u003c apoc.date.parse(o.orderDate,\u0027s\u0027,\u0027yyyy-MM-dd HH:mm:ss.SSS\u0027) \u003c endDate\nRETURN count(o)\n\nIn our query above, we first set the campaign start timestamp as a variable and then pass that to the next line, where we also use that startDate to calculate our end date (using the procedure). The apoc.date.add calculates it by adding 30 days (the 30 and d parameters) to the start date and setting that as our endDate. We then search for Order nodes where the orderDate (converted from string to integer using apoc.date.parse()) is greater than the start date of the campaign and less than the end date.\n\nIn the return, we should see the number of orders made within 30 days of the campaign publish - a total of 70!",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.669",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d apoc.date.add Example:\u003c/p\u003e\n\u003cp\u003eWITH 891388800 as startDate\u003cbr /\u003e\nWITH startDate, apoc.date.add(startDate, \u0026lsquo;s\u0026rsquo;, 30, \u0026lsquo;d\u0026rsquo;) as endDate\u003cbr /\u003e\nMATCH (o:Order)\u003cbr /\u003e\nWHERE startDate \u0026lt; apoc.date.parse(o.orderDate,\u0026lsquo;s\u0026rsquo;,\u0026lsquo;yyyy-MM-dd HH:mm:ss.SSS\u0026rsquo;) \u0026lt; endDate\u003cbr /\u003e\nRETURN count(o)\u003c/p\u003e\n\u003cp\u003eIn our query above, we first set the campaign start timestamp as a variable and then pass that to the next line, where we also use that startDate to calculate our end date (using the procedure). The apoc.date.add calculates it by adding 30 days (the 30 and d parameters) to the start date and setting that as our endDate. We then search for Order nodes where the orderDate (converted from string to integer using apoc.date.parse()) is greater than the start date of the campaign and less than the end date.\u003c/p\u003e\n\u003cp\u003eIn the return, we should see the number of orders made within 30 days of the campaign publish - a total of 70!\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409495647_893356114",
      "id": "paragraph_1635409495647_893356114",
      "dateCreated": "2021-10-28 08:24:55.647",
      "dateStarted": "2021-10-29 12:08:53.940",
      "dateFinished": "2021-10-29 12:08:53.955",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\u003d\u003d Converting date string to temporal type\n\nSo far, we have worked with order dates as strings with a particular format. However, Neo4j supports date and time types, so it would probably make things much easier if we converted to the native types.\n\nThere is an APOC procedure to convert the format from a string to a temporal type. Since Neo4j is compatible with the ISO 8601 standard, we will use that for our result format.\n\nFormat: apoc.date.convertFormat(\u00272019-12-31 16:14:20\u0027, \u0027yyyy-MM-dd HH:mm:ss\u0027, \u0027iso_date_format\u0027)\n\nThe procedure contains 3 parameters -\n\n    the date string that needs converted\n\n    what the format is of the date string\n\n    the format for the resulting temporal type (can be specified manually, as Java formats, or as these built-in formats)\n\n\u003d\u003d\napoc.date.convertFormat Example:\n\nMATCH (o:Order)\nSET o.isoOrderDate \u003d apoc.date.convertFormat(o.orderDate, \u0027yyyy-MM-dd HH:mm:ss.SSS\u0027, \u0027iso_date_time\u0027)\nRETURN o\n\nIn the query above, we find all the orders in our system and set a new property called isoOrderDate that is equal to the converted orderDate string. The orderDate is converted using the procedure, specifying the string format it is currently in and the iso_date_time format (2019-01-01T00:00:00) we want to have as the result.\n\nResults of the query should return a sample (Browser will limit how much JavaScript has to render) of the orders we updated. Clicking on one shows all the properties on that node, including the new isoOrderDate property that is formatted as we expected!\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:15:11.519",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Converting date string to temporal type\u003c/p\u003e\n\u003cp\u003eSo far, we have worked with order dates as strings with a particular format. However, Neo4j supports date and time types, so it would probably make things much easier if we converted to the native types.\u003c/p\u003e\n\u003cp\u003eThere is an APOC procedure to convert the format from a string to a temporal type. Since Neo4j is compatible with the ISO 8601 standard, we will use that for our result format.\u003c/p\u003e\n\u003cp\u003eFormat: apoc.date.convertFormat(\u0026lsquo;2019-12-31 16:14:20\u0026rsquo;, \u0026lsquo;yyyy-MM-dd HH:mm:ss\u0026rsquo;, \u0026lsquo;iso_date_format\u0026rsquo;)\u003c/p\u003e\n\u003cp\u003eThe procedure contains 3 parameters -\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ethe date string that needs converted\n\nwhat the format is of the date string\n\nthe format for the resulting temporal type (can be specified manually, as Java formats, or as these built-in formats)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003d\u003d\u003cbr /\u003e\napoc.date.convertFormat Example:\u003c/p\u003e\n\u003cp\u003eMATCH (o:Order)\u003cbr /\u003e\nSET o.isoOrderDate \u003d apoc.date.convertFormat(o.orderDate, \u0026lsquo;yyyy-MM-dd HH:mm:ss.SSS\u0026rsquo;, \u0026lsquo;iso_date_time\u0026rsquo;)\u003cbr /\u003e\nRETURN o\u003c/p\u003e\n\u003cp\u003eIn the query above, we find all the orders in our system and set a new property called isoOrderDate that is equal to the converted orderDate string. The orderDate is converted using the procedure, specifying the string format it is currently in and the iso_date_time format (2019-01-01T00:00:00) we want to have as the result.\u003c/p\u003e\n\u003cp\u003eResults of the query should return a sample (Browser will limit how much JavaScript has to render) of the orders we updated. Clicking on one shows all the properties on that node, including the new isoOrderDate property that is formatted as we expected!\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635409505023_265615401",
      "id": "paragraph_1635409505023_265615401",
      "dateCreated": "2021-10-28 08:25:05.023",
      "dateStarted": "2021-10-29 12:08:54.055",
      "dateFinished": "2021-10-29 12:08:54.066",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d apoc.convert\n\ndacanc: if I want a map representation of a node\nCREATE (node:Node {id: 4})\nRETURN apoc.convert.toMap(node) AS output;\n\n\u003d\u003d apoc.convert.toList\n\nWhat if we want to take the first element from each path? We could try to do it like this:\n\nCypher\nCopy to Clipboard\nRun in Neo4j Browser\nMATCH path \u003d ()-[:ACTED_IN]-\u003e()\nRETURN path[0];\nResults\nText\nCopy to Clipboard\nType mismatch: expected List\u003cT\u003e but was Path (line 3, column 8 (offset: 40))\n\"RETURN path[0];\"\n^\nWe can use apoc.convert.toList to convert the path to a list and then take the first item from that list:\n\nCypher\nCopy to Clipboard\nRun in Neo4j Browser\nMATCH path \u003d ()-[:ACTED_IN]-\u003e()\nRETURN apoc.convert.toList(path)[0];\n\n\n\n\n\n\n\u003d\u003d MAP FUNCTION\nhttps://neo4j.com/labs/apoc/4.1/data-structures/map-functions/\n\n\u003d\u003d COLL FUNCTION\nhttps://neo4j.com/labs/apoc/4.1/data-structures/collection-list-functions/\n\napoc.coll.randomItem",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.696",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d apoc.convert\u003c/p\u003e\n\u003cp\u003edacanc: if I want a map representation of a node\u003cbr /\u003e\nCREATE (node:Node {id: 4})\u003cbr /\u003e\nRETURN apoc.convert.toMap(node) AS output;\u003c/p\u003e\n\u003cp\u003e\u003d\u003d apoc.convert.toList\u003c/p\u003e\n\u003cp\u003eWhat if we want to take the first element from each path? We could try to do it like this:\u003c/p\u003e\n\u003cp\u003eCypher\u003cbr /\u003e\nCopy to Clipboard\u003cbr /\u003e\nRun in Neo4j Browser\u003cbr /\u003e\nMATCH path \u003d ()-[:ACTED_IN]-\u0026gt;()\u003cbr /\u003e\nRETURN path[0];\u003cbr /\u003e\nResults\u003cbr /\u003e\nText\u003cbr /\u003e\nCopy to Clipboard\u003cbr /\u003e\nType mismatch: expected List\u003cT\u003e but was Path (line 3, column 8 (offset: 40))\u003cbr /\u003e\n\u0026ldquo;RETURN path[0];\u0026rdquo;\u003cbr /\u003e\n^\u003cbr /\u003e\nWe can use apoc.convert.toList to convert the path to a list and then take the first item from that list:\u003c/p\u003e\n\u003cp\u003eCypher\u003cbr /\u003e\nCopy to Clipboard\u003cbr /\u003e\nRun in Neo4j Browser\u003cbr /\u003e\nMATCH path \u003d ()-[:ACTED_IN]-\u0026gt;()\u003cbr /\u003e\nRETURN apoc.convert.toList(path)[0];\u003c/p\u003e\n\u003cp\u003e\u003d\u003d MAP FUNCTION\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/data-structures/map-functions/\"\u003ehttps://neo4j.com/labs/apoc/4.1/data-structures/map-functions/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003d\u003d COLL FUNCTION\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/data-structures/collection-list-functions/\"\u003ehttps://neo4j.com/labs/apoc/4.1/data-structures/collection-list-functions/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eapoc.coll.randomItem\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635410629828_1292976084",
      "id": "paragraph_1635410629828_1292976084",
      "dateCreated": "2021-10-28 08:43:49.828",
      "dateStarted": "2021-10-29 12:08:54.174",
      "dateFinished": "2021-10-29 12:08:54.187",
      "status": "FINISHED"
    },
    {
      "text": "%md\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 12:08:56.709",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635410637176_2038794128",
      "id": "paragraph_1635410637176_2038794128",
      "dateCreated": "2021-10-28 08:43:57.176",
      "status": "FINISHED"
    }
  ],
  "name": "Property and composite types manipulation",
  "id": "2GN8QQ2U3",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {
    "isRunning": false
  }
}