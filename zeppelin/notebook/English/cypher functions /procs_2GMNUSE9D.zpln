{
  "paragraphs": [
    {
      "text": "\u003d\u003d APOC CUSTOM FUNCTION\n\n- apoc.custom.declareFunction() \n    esempio come nel video\n- apoc.custom.declareProcedure()\n    esempio come nel video\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 15:39:27.230",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "scala",
          "editOnDblClick": false,
          "completionKey": "TAB",
          "completionSupport": true
        },
        "editorMode": "ace/mode/scala"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349165369_363843619",
      "id": "paragraph_1635349165369_363843619",
      "dateCreated": "2021-10-27 15:39:25.369",
      "status": "READY"
    },
    {
      "text": "%md\n\n\n\n\u003d\u003d Timeboxed Cypher statement\n// todo - titolo più esplicativo (tipo how to timeout a query) \n\nThere\u0027s a way to terminate a cypher statement if it takes longer than a given threshold. Consider an expensive statement calculating cross product of shortestpaths for each pair of nodes:\n\n[source,cypher]\n----\nCALL apoc.cypher.runTimeboxed(\n  \"match (n),(m) match p\u003dshortestPath((n)-[*]-(m)) return p\",\n  null,\n  10000\n)\nYIELD value\nRETURN value.p\n----\n\nThis will return all results computed within 10000 milliseconds.\nThe statement will be terminated after that period.\n\n\n\u003d\u003d Run multiple statements at once\n// todo - unirlo alla cypher.run\n\nThis procedure runs each semicolon separated statement and returns summary - currently no schema operations.\n\n[source,cypher]\n----\nCALL apoc.cypher.runMany(\u0027cypher;\\nstatements;\u0027,{params},[{statistics:true,timeout:10}])\n----\n\n\n\u003d\u003d Run Cypher script files\n// todo - collegarlo alla export cypher, o dire (come vedremo in seguito)\n\n\nRuns each statement in the file / each file, all semicolon separated\n\nThese procedures can be used to run files that are usually run by cypher-shell.\ne.g. files generated by xref::export/cypher.adoc[].\nThey automatically skip `:begin/:commit/:rollback` operations as they are executed in a single transaction per file.\n\n[[run-cypher-scripts-overview]]\n\u003d\u003d\u003d Procedure Overview\n\nThe available procedures and functions are described in the following table:\n\n[separator\u003d¦,opts\u003dheader,cols\u003d\"5,1m,1m\"]\n|\u003d\u003d\u003d\n¦Qualified Name¦Type¦Release\ninclude::example$generated-documentation/apoc.cypher.runFile.adoc[]\ninclude::example$generated-documentation/apoc.cypher.runFiles.adoc[]\ninclude::example$generated-documentation/apoc.cypher.runSchemaFile.adoc[]\ninclude::example$generated-documentation/apoc.cypher.runSchemaFiles.adoc[]\n|\u003d\u003d\u003d\n\n[[run-cypher-scripts-data-operations]]\n\u003d\u003d\u003d Data Operations only\n\n* `apoc.cypher.runFile(file or url,[\\{config}])`\n* `apoc.cypher.runFiles([files or urls],[\\{config})])`\n\nThe `apoc.cypher.run*File(s)` procedures have some optional configuration:\n\n* `{statistics:true/false}` to output a row of update-stats per statement, default is true\n* `{timeout:1 or 10}` for how long the stream waits for new data, default is 10\n\n[[run-cypher-scripts-schema-operations]]\n\u003d\u003d Schema Operations only\n\n* `apoc.cypher.runSchemaFile(file or url,[\\{config}])`\n* `apoc.cypher.runSchemaFiles([files or urls],[\\{config})])`\n\n\n\n\u003d\u003d Custom, Cypher Based Procedures and Functions\n\n\n\nI wanted for a long time to be able to register Cypher statements as proper procedures and functions, so that they become callable in a standalone way.\n\nYou can achieve that with the `apoc.custom.asProcedure` and `apoc.custom.asFunction` procedure calls.\nThose register a given Cypher statement, prefixed with the `custom.*` namespace, overriding potentially existing ones, so you can redefine them as needed.\n\nHere is a simple example:\n\n[source,cypher]\n----\nCALL apoc.custom.asProcedure(\u0027answer\u0027,\u0027RETURN 42 as answer\u0027)\n----\n\nThis registers the statement as procedure `custom.answer` that you then can call.\nAs no information on parameter and return types is given, it just returns a stream of columns of maps called `row`.\n\n[source,cypher]\n----\nCALL custom.answer YIELD row\nRETURN row.answer\n----\n\nThe same is possible as a function:\n\n[source,cypher]\n----\nCALL apoc.custom.asFunction(\u0027answer\u0027,\u0027RETURN 42\u0027)\n----\n\nNOTE: If you override procedures or functions you might need to call `call dbms.clearQueryCaches()` as lookups to internal id\u0027s are kept in compiled query plans.\n\n\u003d\u003d\u003d Custom Procedures with `apoc.custom.asProcedure`\n\nGiven statement will be registered as a procedure, the results will be turned into a stream of records.\n\n.Parameters\n[%autowidth,opts\u003dheader,cols\u003d\"m,m,a\"]\n|\u003d\u003d\u003d\n| name\n| default\n| description\n\n| name | none | dot-separated name, will be prefixed with `custom`\n| statement | none | cypher statement to run, can use $parameters\n| mode | read | execution mode of the procedure: read, write, or schema\n| outputs | [[\"row\",\"MAP\"]] | List of pairs of name-type to be used as output columns, need to be in-order with the cypher statement, the default is a special case, that will collect all columns of the statement result into a map\n| inputs | [[\"params\",\"MAP\",\"{}\"]] | Pairs or triples of name-type-default, to be used as input parameters. The default just takes an optional map, otherwise they will become proper paramters in order\n| description | \"\" | A general description about the business rules implemented into the procedure\n|\u003d\u003d\u003d\n\nThe type names are what you would expect and see in outputs of `dbms.procedures` or `apoc.help` just without the `?`.\nThe default values are parsed as JSON.\n\n.Type Names\n* FLOAT, DOUBLE, INT, INTEGER, NUMBER, LONG\n* TEXT, STRING\n* BOOL, BOOLEAN\n* POINT, GEO, GEOMETRY\n* DATE, DATETIME, LOCALDATETIME, TIME, LOCALTIME, DURATION\n* NODE, REL, RELATIONSHIP, EDGE, PATH\n* MAP\n* LIST TYPE, LIST OF TYPE (where `TYPE` can be one of the previous values)\n* ANY\n\n.Find neighbours of a node by name\n[source,cypher]\n----\nCALL apoc.custom.asProcedure(\u0027neighbours\u0027,\n  \u0027MATCH (n:Person {name:$name})--\u003e(nb) RETURN nb as neighbour\u0027,\u0027read\u0027,\n  [[\u0027neighbour\u0027,\u0027NODE\u0027]],[[\u0027name\u0027,\u0027STRING\u0027], \u0027get neighbours of a person\u0027]);\n\nCALL custom.neighbours(\u0027Keanu Reeves\u0027) YIELD neighbour;\n----\n\n\n\u003d\u003d\u003d Custom Functions with `apoc.custom.asFunction`\n\n// todo - fare esempi con declareFunction e declareProcedure\nGiven statement will be registered as a statement, the results into a single value.\nIf the given output type is a list, results will be collected into a list, otherwise the first row will be used.\nThe statement needs to return a single column, otherwise an error is thrown.\n\n.Parameters\n[%autowidth,opts\u003dheader, cols\u003d\"m,m,a\"]\n|\u003d\u003d\u003d\n| name\n| default\n| description\n\n| name | none | dot-separated name, will be prefixed with `custom`\n| statement | none | cypher statement to run, can use $parameters\n| outputs | \"LIST OF MAP\" | Output type for single output, if the type is a list, then all rows will be collected, otherwise just the first row. Only single column results are allowed.\nIf your single row result is a list you can force a single row by setting the last parameter to `true`\n| inputs | [[\"params\",\"MAP\",\"{}\"]] | Pairs or triples of name-type-default, to be used as input parameters. The default just takes an optional map, otherwise they will become proper paramters in order\n| singleRow | false | If set to true, the statement is treated as single row even with the list result type, then your statement has to return a list.\n| description | \"\" | A general description about the business rules implemented into the function\n|\u003d\u003d\u003d\n\nThe type names are what you would expect and see in outputs of `dbms.procedures` or `apoc.help` just without the `?`.\nThe default values are parsed as JSON.\n\n\n\u003d\u003d\u003d List of registered procedures/function with `apoc.custom.list`\n\nThe procedure `apoc.custom.list` provide a list of all registered procedures/function via\n`apoc.custom.asProcedure` and `apoc.custom.asFunction`\n\nGiven the this call:\n\n[source,cypher]\n----\nCALL apoc.custom.list\n----\n\nThe the output will look like the following table:\n\n[%autowidth,opts\u003dheader]\n|\u003d\u003d\u003d\n| type | name | description | mode | statement | inputs | outputs | forceSingle\n| \"function\"  | \"answer\" | \u003cnull\u003e | \u003cnull\u003e | \"RETURN $input as answer\" | [[\"input\",\"number\"]] | \"long\" | false\n| \"procedure\" | \"answer\" | \"Procedure that answer to the Ultimate Question of Life, the Universe, and Everything\" | \"read\" | \"RETURN $input as answer\" | [[\"input\",\"int\",\"42\"]] | [[\"answer\",\"number\"]] | \u003cnull\u003e\n|\u003d\u003d\u003d\n\n\n\u003d\u003d\u003d Remove a procedure `apoc.custom.removeProcedure`\n\nThe procedure `apoc.custom.removeProcedure` allows to delete the targeted custom procedure.\n\n\nWith this call:\n\n[source,cypher]\n----\nCALL apoc.custom.removeProcedure(\u003cname\u003e)\n----\n\nFields:\n\n[%autowidth,opts\u003dheader]\n|\u003d\u003d\u003d\n| argument | description\n| name  | the procedure name\n|\u003d\u003d\u003d\n\n\n\u003d\u003d\u003d Remove a procedure `apoc.custom.removeFunction`\n\nThe procedure `apoc.custom.removeFunction` allows to delete the targeted custom function.\n\n\nGiven the this call:\n\n[source,cypher]\n----\nCALL apoc.custom.removeFunction(\u003cname\u003e)\n----\n\nFields:\n\n[%autowidth,opts\u003dheader]\n|\u003d\u003d\u003d\n| argument | description\n| name  | the function name\n|\u003d\u003d\u003d\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 23:06:33.236",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "language": "markdown",
          "editOnDblClick": true,
          "completionKey": "TAB",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Timeboxed Cypher statement\u003cbr /\u003e\n// todo - titolo più esplicativo (tipo how to timeout a query)\u003c/p\u003e\n\u003cp\u003eThere\u0026rsquo;s a way to terminate a cypher statement if it takes longer than a given threshold. Consider an expensive statement calculating cross product of shortestpaths for each pair of nodes:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.cypher.runTimeboxed(\u003cbr /\u003e\n\u0026ldquo;match (n),(m) match p\u003dshortestPath((n)-[*]-(m)) return p\u0026rdquo;,\u003cbr /\u003e\nnull,\u003cbr /\u003e\n10000\u003cbr /\u003e\n)\u003cbr /\u003e\nYIELD value\u003cbr /\u003e\nRETURN value.p\u003c/h2\u003e\n\u003cp\u003eThis will return all results computed within 10000 milliseconds.\u003cbr /\u003e\nThe statement will be terminated after that period.\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Run multiple statements at once\u003cbr /\u003e\n// todo - unirlo alla cypher.run\u003c/p\u003e\n\u003cp\u003eThis procedure runs each semicolon separated statement and returns summary - currently no schema operations.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.cypher.runMany(\u0026lsquo;cypher;\\nstatements;\u0026rsquo;,{params},[{statistics:true,timeout:10}])\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d Run Cypher script files\u003cbr /\u003e\n// todo - collegarlo alla export cypher, o dire (come vedremo in seguito)\u003c/p\u003e\n\u003cp\u003eRuns each statement in the file / each file, all semicolon separated\u003c/p\u003e\n\u003cp\u003eThese procedures can be used to run files that are usually run by cypher-shell.\u003cbr /\u003e\ne.g. files generated by xref::export/cypher.adoc[].\u003cbr /\u003e\nThey automatically skip \u003ccode\u003e:begin/:commit/:rollback\u003c/code\u003e operations as they are executed in a single transaction per file.\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"run-cypher-scripts-overview\"\u003erun-cypher-scripts-overview\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d\u003d Procedure Overview\u003c/p\u003e\n\u003cp\u003eThe available procedures and functions are described in the following table:\u003c/p\u003e\n\u003cp\u003e[separator\u003d¦,opts\u003dheader,cols\u003d\u0026ldquo;5,1m,1m\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n¦Qualified Name¦Type¦Release\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.cypher.runFile.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.cypher.runFiles.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.cypher.runSchemaFile.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.cypher.runSchemaFiles.adoc[]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"run-cypher-scripts-data-operations\"\u003erun-cypher-scripts-data-operations\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d\u003d Data Operations only\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eapoc.cypher.runFile(file or url,[\\{config}])\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eapoc.cypher.runFiles([files or urls],[\\{config})])\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe \u003ccode\u003eapoc.cypher.run*File(s)\u003c/code\u003e procedures have some optional configuration:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e{statistics:true/false}\u003c/code\u003e to output a row of update-stats per statement, default is true\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e{timeout:1 or 10}\u003c/code\u003e for how long the stream waits for new data, default is 10\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ca href\u003d\"run-cypher-scripts-schema-operations\"\u003erun-cypher-scripts-schema-operations\u003c/a\u003e\u003cbr /\u003e\n\u003d\u003d Schema Operations only\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eapoc.cypher.runSchemaFile(file or url,[\\{config}])\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eapoc.cypher.runSchemaFiles([files or urls],[\\{config})])\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003d\u003d Custom, Cypher Based Procedures and Functions\u003c/p\u003e\n\u003cp\u003eI wanted for a long time to be able to register Cypher statements as proper procedures and functions, so that they become callable in a standalone way.\u003c/p\u003e\n\u003cp\u003eYou can achieve that with the \u003ccode\u003eapoc.custom.asProcedure\u003c/code\u003e and \u003ccode\u003eapoc.custom.asFunction\u003c/code\u003e procedure calls.\u003cbr /\u003e\nThose register a given Cypher statement, prefixed with the \u003ccode\u003ecustom.*\u003c/code\u003e namespace, overriding potentially existing ones, so you can redefine them as needed.\u003c/p\u003e\n\u003cp\u003eHere is a simple example:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.custom.asProcedure(\u0026lsquo;answer\u0026rsquo;,\u0026lsquo;RETURN 42 as answer\u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003eThis registers the statement as procedure \u003ccode\u003ecustom.answer\u003c/code\u003e that you then can call.\u003cbr /\u003e\nAs no information on parameter and return types is given, it just returns a stream of columns of maps called \u003ccode\u003erow\u003c/code\u003e.\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL custom.answer YIELD row\u003cbr /\u003e\nRETURN row.answer\u003c/h2\u003e\n\u003cp\u003eThe same is possible as a function:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.custom.asFunction(\u0026lsquo;answer\u0026rsquo;,\u0026lsquo;RETURN 42\u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003eNOTE: If you override procedures or functions you might need to call \u003ccode\u003ecall dbms.clearQueryCaches()\u003c/code\u003e as lookups to internal id\u0026rsquo;s are kept in compiled query plans.\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Custom Procedures with \u003ccode\u003eapoc.custom.asProcedure\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eGiven statement will be registered as a procedure, the results will be turned into a stream of records.\u003c/p\u003e\n\u003cp\u003e.Parameters\u003cbr /\u003e\n[%autowidth,opts\u003dheader,cols\u003d\u0026ldquo;m,m,a\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| name\u003cbr /\u003e\n| default\u003cbr /\u003e\n| description\u003c/p\u003e\n\u003cp\u003e| name | none | dot-separated name, will be prefixed with \u003ccode\u003ecustom\u003c/code\u003e\u003cbr /\u003e\n| statement | none | cypher statement to run, can use $parameters\u003cbr /\u003e\n| mode | read | execution mode of the procedure: read, write, or schema\u003cbr /\u003e\n| outputs | \u003ca href\u003d\"\u0026quot;row\u0026quot;,\u0026quot;MAP\u0026quot;\"\u003e\u0026quot;row\u0026quot;,\u0026quot;MAP\u0026quot;\u003c/a\u003e | List of pairs of name-type to be used as output columns, need to be in-order with the cypher statement, the default is a special case, that will collect all columns of the statement result into a map\u003cbr /\u003e\n| inputs | \u003ca href\u003d\"\u0026quot;params\u0026quot;,\u0026quot;MAP\u0026quot;,\u0026quot;{}\u0026quot;\"\u003e\u0026quot;params\u0026quot;,\u0026quot;MAP\u0026quot;,\u0026quot;{}\u0026quot;\u003c/a\u003e | Pairs or triples of name-type-default, to be used as input parameters. The default just takes an optional map, otherwise they will become proper paramters in order\u003cbr /\u003e\n| description | \u0026quot;\u0026quot; | A general description about the business rules implemented into the procedure\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThe type names are what you would expect and see in outputs of \u003ccode\u003edbms.procedures\u003c/code\u003e or \u003ccode\u003eapoc.help\u003c/code\u003e just without the \u003ccode\u003e?\u003c/code\u003e.\u003cbr /\u003e\nThe default values are parsed as JSON.\u003c/p\u003e\n\u003cp\u003e.Type Names\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eFLOAT, DOUBLE, INT, INTEGER, NUMBER, LONG\u003c/li\u003e\n\u003cli\u003eTEXT, STRING\u003c/li\u003e\n\u003cli\u003eBOOL, BOOLEAN\u003c/li\u003e\n\u003cli\u003ePOINT, GEO, GEOMETRY\u003c/li\u003e\n\u003cli\u003eDATE, DATETIME, LOCALDATETIME, TIME, LOCALTIME, DURATION\u003c/li\u003e\n\u003cli\u003eNODE, REL, RELATIONSHIP, EDGE, PATH\u003c/li\u003e\n\u003cli\u003eMAP\u003c/li\u003e\n\u003cli\u003eLIST TYPE, LIST OF TYPE (where \u003ccode\u003eTYPE\u003c/code\u003e can be one of the previous values)\u003c/li\u003e\n\u003cli\u003eANY\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e.Find neighbours of a node by name\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003cp\u003eCALL apoc.custom.asProcedure(\u0026lsquo;neighbours\u0026rsquo;,\u003cbr /\u003e\n\u0026lsquo;MATCH (n:Person {name:$name})\u0026ndash;\u0026gt;(nb) RETURN nb as neighbour\u0026rsquo;,\u0026lsquo;read\u0026rsquo;,\u003cbr /\u003e\n\u003ca href\u003d\"\u0027neighbour\u0027,\u0027NODE\u0027\"\u003e\u0026rsquo;neighbour\u0026rsquo;,\u0026rsquo;NODE\u0026rsquo;\u003c/a\u003e,[[\u0026lsquo;name\u0026rsquo;,\u0026lsquo;STRING\u0026rsquo;], \u0026lsquo;get neighbours of a person\u0026rsquo;]);\u003c/p\u003e\n\u003ch2\u003eCALL custom.neighbours(\u0026lsquo;Keanu Reeves\u0026rsquo;) YIELD neighbour;\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d\u003d Custom Functions with \u003ccode\u003eapoc.custom.asFunction\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e// todo - fare esempi con declareFunction e declareProcedure\u003cbr /\u003e\nGiven statement will be registered as a statement, the results into a single value.\u003cbr /\u003e\nIf the given output type is a list, results will be collected into a list, otherwise the first row will be used.\u003cbr /\u003e\nThe statement needs to return a single column, otherwise an error is thrown.\u003c/p\u003e\n\u003cp\u003e.Parameters\u003cbr /\u003e\n[%autowidth,opts\u003dheader, cols\u003d\u0026ldquo;m,m,a\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| name\u003cbr /\u003e\n| default\u003cbr /\u003e\n| description\u003c/p\u003e\n\u003cp\u003e| name | none | dot-separated name, will be prefixed with \u003ccode\u003ecustom\u003c/code\u003e\u003cbr /\u003e\n| statement | none | cypher statement to run, can use $parameters\u003cbr /\u003e\n| outputs | \u0026ldquo;LIST OF MAP\u0026rdquo; | Output type for single output, if the type is a list, then all rows will be collected, otherwise just the first row. Only single column results are allowed.\u003cbr /\u003e\nIf your single row result is a list you can force a single row by setting the last parameter to \u003ccode\u003etrue\u003c/code\u003e\u003cbr /\u003e\n| inputs | \u003ca href\u003d\"\u0026quot;params\u0026quot;,\u0026quot;MAP\u0026quot;,\u0026quot;{}\u0026quot;\"\u003e\u0026quot;params\u0026quot;,\u0026quot;MAP\u0026quot;,\u0026quot;{}\u0026quot;\u003c/a\u003e | Pairs or triples of name-type-default, to be used as input parameters. The default just takes an optional map, otherwise they will become proper paramters in order\u003cbr /\u003e\n| singleRow | false | If set to true, the statement is treated as single row even with the list result type, then your statement has to return a list.\u003cbr /\u003e\n| description | \u0026quot;\u0026quot; | A general description about the business rules implemented into the function\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eThe type names are what you would expect and see in outputs of \u003ccode\u003edbms.procedures\u003c/code\u003e or \u003ccode\u003eapoc.help\u003c/code\u003e just without the \u003ccode\u003e?\u003c/code\u003e.\u003cbr /\u003e\nThe default values are parsed as JSON.\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d List of registered procedures/function with \u003ccode\u003eapoc.custom.list\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe procedure \u003ccode\u003eapoc.custom.list\u003c/code\u003e provide a list of all registered procedures/function via\u003cbr /\u003e\n\u003ccode\u003eapoc.custom.asProcedure\u003c/code\u003e and \u003ccode\u003eapoc.custom.asFunction\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eGiven the this call:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.custom.list\u003c/h2\u003e\n\u003cp\u003eThe the output will look like the following table:\u003c/p\u003e\n\u003cp\u003e[%autowidth,opts\u003dheader]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| type | name | description | mode | statement | inputs | outputs | forceSingle\u003cbr /\u003e\n| \u0026ldquo;function\u0026rdquo;  | \u0026ldquo;answer\u0026rdquo; | \u003cnull\u003e | \u003cnull\u003e | \u0026ldquo;RETURN $input as answer\u0026rdquo; | \u003ca href\u003d\"\u0026quot;input\u0026quot;,\u0026quot;number\u0026quot;\"\u003e\u0026quot;input\u0026quot;,\u0026quot;number\u0026quot;\u003c/a\u003e | \u0026ldquo;long\u0026rdquo; | false\u003cbr /\u003e\n| \u0026ldquo;procedure\u0026rdquo; | \u0026ldquo;answer\u0026rdquo; | \u0026ldquo;Procedure that answer to the Ultimate Question of Life, the Universe, and Everything\u0026rdquo; | \u0026ldquo;read\u0026rdquo; | \u0026ldquo;RETURN $input as answer\u0026rdquo; | \u003ca href\u003d\"\u0026quot;input\u0026quot;,\u0026quot;int\u0026quot;,\u0026quot;42\u0026quot;\"\u003e\u0026quot;input\u0026quot;,\u0026quot;int\u0026quot;,\u0026quot;42\u0026quot;\u003c/a\u003e | \u003ca href\u003d\"\u0026quot;answer\u0026quot;,\u0026quot;number\u0026quot;\"\u003e\u0026quot;answer\u0026quot;,\u0026quot;number\u0026quot;\u003c/a\u003e | \u003cnull\u003e\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Remove a procedure \u003ccode\u003eapoc.custom.removeProcedure\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe procedure \u003ccode\u003eapoc.custom.removeProcedure\u003c/code\u003e allows to delete the targeted custom procedure.\u003c/p\u003e\n\u003cp\u003eWith this call:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.custom.removeProcedure(\u003cname\u003e)\u003c/h2\u003e\n\u003cp\u003eFields:\u003c/p\u003e\n\u003cp\u003e[%autowidth,opts\u003dheader]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| argument | description\u003cbr /\u003e\n| name  | the procedure name\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Remove a procedure \u003ccode\u003eapoc.custom.removeFunction\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003eThe procedure \u003ccode\u003eapoc.custom.removeFunction\u003c/code\u003e allows to delete the targeted custom function.\u003c/p\u003e\n\u003cp\u003eGiven the this call:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.custom.removeFunction(\u003cname\u003e)\u003c/h2\u003e\n\u003cp\u003eFields:\u003c/p\u003e\n\u003cp\u003e[%autowidth,opts\u003dheader]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| argument | description\u003cbr /\u003e\n| name  | the function name\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635375985896_17899957",
      "id": "paragraph_1635375985896_17899957",
      "dateCreated": "2021-10-27 23:06:25.896",
      "dateStarted": "2021-10-27 23:06:33.229",
      "dateFinished": "2021-10-27 23:06:33.288",
      "status": "FINISHED"
    },
    {
      "text": "%md\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-27 23:06:33.228",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635375993228_1735917923",
      "id": "paragraph_1635375993228_1735917923",
      "dateCreated": "2021-10-27 23:06:33.228",
      "status": "READY"
    }
  ],
  "name": "procs",
  "id": "2GMNUSE9D",
  "defaultInterpreterGroup": "spark",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}