{
  "paragraphs": [
    {
      "text": "%md\n\n\u003d\u003d Static values\n\n// The library has support for storing and retrieving static values, functionality that can be used to work with API credentials or cache query results.\n// esempio come di issue github che ho chiuso\nhttps://neo4j.com/labs/apoc/4.1/misc/static-values/\n\n\nThe examples below assume that we have the following entries in the APOC configuration file (`conf/apoc.conf`):\n\n----\napoc.static.twitter.bearer\u003dABCDEF\napoc.static.twitter.url\u003dhttps://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026result_type\u003drecent\u0026lang\u003den\u0026q\u003d\n----\n\n.The following returns the `apoc.static.twitter.bearer` value:\n[source,cypher]\n----\nRETURN apoc.static.get(\"twitter.bearer\") AS value\n----\n\n.Results\n[opts\u003d\"header\",cols\u003d\"1\"]\n|\u003d\u003d\u003d\n| value\n| \"ABCDEF\"\n|\u003d\u003d\u003d\n\n\n.The following returns all values with the `twitter` prefix\n[source,cypher]\n----\nRETURN apoc.static.getAll(\"twitter\") AS value\n----\n\n.Results\n[opts\u003d\"header\",cols\u003d\"1\"]\n|\u003d\u003d\u003d\n| value\n| {\"bearer\":\"ABCDEF\",\"url\":\"https://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026result_type\u003drecent\u0026lang\u003den\u0026q\u003d\"}\n|\u003d\u003d\u003d\n\n\n.The following stores an in memory value that lasts for the lifetime of the server:\n[source,cypher]\n----\nCALL apoc.static.set(\"twitter.user\", \"Michael\")\n----\n\n.Results\n[opts\u003d\"header\",cols\u003d\"1\"]\n|\u003d\u003d\u003d\n| value\n| null\n|\u003d\u003d\u003d\n\n// todo - fare dopo load jdbc questo esempio\n[source,cypher]\n----\nCALL apoc.load.jdbc(\u0027jdbc:oracle:thin:@HOST:PORT/SERVICE_NAME\u0027,\n\u0027select * from dual\u0027, [],\n{   credentials:{user:apoc.static.get(\"apoc.static.jdbc.\u003ckey\u003e.user\"), password: apoc.static.get(\"apoc.static.jdbc.\u003ckey\u003e.password\")}})\nYIELD row\nRETURN row\n----\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-28 08:56:00.559",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": true
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Static values\u003c/p\u003e\n\u003cp\u003e// The library has support for storing and retrieving static values, functionality that can be used to work with API credentials or cache query results.\u003cbr /\u003e\n// esempio come di issue github che ho chiuso\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/misc/static-values/\"\u003ehttps://neo4j.com/labs/apoc/4.1/misc/static-values/\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eThe examples below assume that we have the following entries in the APOC configuration file (\u003ccode\u003econf/apoc.conf\u003c/code\u003e):\u003c/p\u003e\n\u003chr /\u003e\n\u003ch2\u003eapoc.static.twitter.bearer\u003dABCDEF\u003cbr /\u003e\napoc.static.twitter.url\u003d\u003ca href\u003d\"https://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026amp;result_type\u003drecent\u0026amp;lang\u003den\u0026amp;q\u003d\"\u003ehttps://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026amp;result_type\u003drecent\u0026amp;lang\u003den\u0026amp;q\u003d\u003c/a\u003e\u003c/h2\u003e\n\u003ch2\u003e.The following returns the \u003ccode\u003eapoc.static.twitter.bearer\u003c/code\u003e value:\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.static.get(\u0026ldquo;twitter.bearer\u0026rdquo;) AS value\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;,cols\u003d\u0026ldquo;1\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| value\u003cbr /\u003e\n| \u0026ldquo;ABCDEF\u0026rdquo;\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.The following returns all values with the \u003ccode\u003etwitter\u003c/code\u003e prefix\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.static.getAll(\u0026ldquo;twitter\u0026rdquo;) AS value\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;,cols\u003d\u0026ldquo;1\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| value\u003cbr /\u003e\n| {\u0026ldquo;bearer\u0026rdquo;:\u0026ldquo;ABCDEF\u0026rdquo;,\u0026ldquo;url\u0026rdquo;:\u0026ldquo;\u003ca href\u003d\"https://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026amp;result_type\u003drecent\u0026amp;lang\u003den\u0026amp;q\u003d\"\u003ehttps://api.twitter.com/1.1/search/tweets.json?count\u003d100\u0026amp;result_type\u003drecent\u0026amp;lang\u003den\u0026amp;q\u003d\u003c/a\u003e\u0026rdquo;}\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e.The following stores an in memory value that lasts for the lifetime of the server:\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.static.set(\u0026ldquo;twitter.user\u0026rdquo;, \u0026ldquo;Michael\u0026rdquo;)\u003c/h2\u003e\n\u003cp\u003e.Results\u003cbr /\u003e\n[opts\u003d\u0026ldquo;header\u0026rdquo;,cols\u003d\u0026ldquo;1\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n| value\u003cbr /\u003e\n| null\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e// todo - fare dopo load jdbc questo esempio\u003cbr /\u003e\n[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.load.jdbc(\u0026lsquo;jdbc:oracle:thin:@HOST:PORT/SERVICE_NAME\u0026rsquo;,\u003cbr /\u003e\n\u0026lsquo;select * from dual\u0026rsquo;, [],\u003cbr /\u003e\n{credentials:{user:apoc.static.get(\u0026ldquo;apoc.static.jdbc.\u003ckey\u003e.user\u0026rdquo;), password: apoc.static.get(\u0026ldquo;apoc.static.jdbc.\u003ckey\u003e.password\u0026rdquo;)}})\u003cbr /\u003e\nYIELD row\u003cbr /\u003e\nRETURN row\u003c/h2\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635340803726_1233963523",
      "id": "paragraph_1635340803726_1233963523",
      "dateCreated": "2021-10-27 13:20:03.726",
      "dateStarted": "2021-10-28 08:50:33.887",
      "dateFinished": "2021-10-28 08:50:33.902",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d Conditional exception\n\napoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception\nThe following throws an exception because the predicate is true:\n\nCypher\n[source, cypher]\n----\nWITH true AS predicate\nCALL apoc.util.validate(predicate,\u0027message %d\u0027,[42])\nRETURN count(*);\n----\n\nThe following does nothing because the predicate is false:\n\n[source, cypher]\n----\nWITH false AS predicate\nCALL apoc.util.validate(predicate,\u0027message %d\u0027,[42])\nRETURN count(*);\n----\n\n\nValidate predicate it\u0027s the same but is a function:\n\n\n[source, cypher]\n----\nMATCH (a)\nWHERE apoc.util.validatePredicate(true,\u0027message %d\u0027,[42])\nRETURN a\n----\n\n\n[source, cypher]\n----\nRETURN apoc.util.validatePredicate(false,\u0027message %d\u0027,[42]) AS result\n----\n\n\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-28 08:50:33.987",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Conditional exception\u003c/p\u003e\n\u003cp\u003eapoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception\u003cbr /\u003e\nThe following throws an exception because the predicate is true:\u003c/p\u003e\n\u003ch2\u003eCypher\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH true AS predicate\u003cbr /\u003e\nCALL apoc.util.validate(predicate,\u0026lsquo;message %d\u0026rsquo;,[42])\u003cbr /\u003e\nRETURN count(*);\u003c/h2\u003e\n\u003cp\u003eThe following does nothing because the predicate is false:\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eWITH false AS predicate\u003cbr /\u003e\nCALL apoc.util.validate(predicate,\u0026lsquo;message %d\u0026rsquo;,[42])\u003cbr /\u003e\nRETURN count(*);\u003c/h2\u003e\n\u003cp\u003eValidate predicate it\u0026rsquo;s the same but is a function:\u003c/p\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eMATCH (a)\u003cbr /\u003e\nWHERE apoc.util.validatePredicate(true,\u0026lsquo;message %d\u0026rsquo;,[42])\u003cbr /\u003e\nRETURN a\u003c/h2\u003e\n\u003ch2\u003e[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.util.validatePredicate(false,\u0026lsquo;message %d\u0026rsquo;,[42]) AS result\u003c/h2\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349754442_628927367",
      "id": "paragraph_1635349754442_628927367",
      "dateCreated": "2021-10-27 15:49:14.442",
      "dateStarted": "2021-10-28 08:50:34.003",
      "dateFinished": "2021-10-28 08:50:34.016",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d sleep\n\n\n[.emphasis]\napoc.util.sleep(\u003cduration\u003e) | sleeps for \u003cduration\u003e millis, transaction termination is honored\n\n\n// -- in this example we leverage on apoc.date.format to retrieve minutes and seconds\n[source, cypher]\n----\nWITH apoc.date.currentTimestamp() as timeBefore\nCALL apoc.util.sleep(4000)\nRETURN apoc.date.format(timeBefore, \u0027ms\u0027,\u0027mm:ss\u0027), apoc.date.format(apoc.date.currentTimestamp(), \u0027ms\u0027,\u0027mm:ss\u0027)\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-28 08:50:34.103",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d sleep\u003c/p\u003e\n\u003cp\u003e[.emphasis]\u003cbr /\u003e\napoc.util.sleep(\u003cduration\u003e) | sleeps for \u003cduration\u003e millis, transaction termination is honored\u003c/p\u003e\n\u003ch2\u003e// \u0026ndash; in this example we leverage on apoc.date.format to retrieve minutes and seconds\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003cp\u003eWITH apoc.date.currentTimestamp() as timeBefore\u003cbr /\u003e\nCALL apoc.util.sleep(4000)\u003cbr /\u003e\nRETURN apoc.date.format(timeBefore, \u0026lsquo;ms\u0026rsquo;,\u0026lsquo;mm:ss\u0026rsquo;), apoc.date.format(apoc.date.currentTimestamp(), \u0026lsquo;ms\u0026rsquo;,\u0026lsquo;mm:ss\u0026rsquo;)\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349766818_1822740037",
      "id": "paragraph_1635349766818_1822740037",
      "dateCreated": "2021-10-27 15:49:26.818",
      "dateStarted": "2021-10-28 08:50:34.116",
      "dateFinished": "2021-10-28 08:50:34.124",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\n\u003d\u003d Temporal (Date Time)\n\ntodo - esempio per conversion \ntodo 2 - integrarlo con parte di sopra\nhttps://neo4j.com/labs/apoc/4.1/temporal/ --\u003e tanta roba... solo alcune\n\n\n\u003d\u003d Graph Updates\n\nhttps://neo4j.com/labs/apoc/4.1/graph-updates/ --\u003e tanta roba... solo alcune\nCreating Data\nGraph Refactorings\nUUIDs\nPeriodic Execution\nAtomic Property Updates\nLocking\nTime To Live (TTL) - Expire Nodes\nGenerating Graphs\nDeleting Data\n\n\n\u003d\u003d ttl\n\nSome nodes are not meant to live forever. That’s why with APOC you can specify a time by when they are removed from the database, by utilizing a schema index and an additional label. A few procedures help with that.\n\nconf: to activate it --\u003e\n    [source, cypher]\n    \u003d\u003d\u003d\n    apoc.ttl.enabled\u003dtrue\u003c\n    # Optional: controls the repeat frequency\n    # apoc.ttl.schedule\u003d5\u003e\n    \u003d\u003d\u003d\n\nFor example (in a specific time): (params: node, epochTime, time unit (ms, s, m, h, d or millis, milliseconds, seconds, minutes, hours, days) )\nMATCH (movie:Movie)\u003c-[produced:PRODUCED]-(person:Person)\nCALL apoc.ttl.expire(person,1585176720,\u0027s\u0027)\nRETURN movie, produced, person\n\nExpire after a periond(same syntax)\nMATCH (movie:Movie)\u003c-[directed:DIRECTED]-(person:Person)\nCALL apoc.ttl.expireIn(person,120,\u0027s\u0027)\nRETURN movie, directed, person\n\nHow it works:\n    Set the :TTL label and ttl property on the node(s) you want to expire.\n    [sfondo grigio]\n    SET n:TTL\n    SET n.ttl \u003d timestamp() + 3600\n    [sfondo grigio]\n\n    The ttl property holds the time when the node is expired in milliseconds since epoch.\n    CREATE INDEX ON :TTL(ttl)\n\n    Remove node(s) that have passed the expiration time or length of time (through the apoc.ttl.schedule\u003d120)\n    MATCH (t:TTL) where t.ttl \u003c timestamp() WITH t LIMIT 1000 DETACH DELETE t\n\n\nttl: emulato come MongoDb o Redis\n\n\n\u003d\u003d uuid\nautomation generation of UUIDs\n\nIn 2 ways:\nManual UUIDs: RETURN apoc.create.uuid() AS uuid; --\u003e e.g.: CREATE (p:Person {id: apoc.create.uuid()})\n\nAuto UUID:\nthrough 4 proc:\napoc.uuid.install(\u0027Label\u0027, `{configMap}`)\n\nExample:\nFirst of all, we need to create a constraint:\n// todo - far vedere che succede se non lo installo\n[source, cypher]\n----\nCREATE CONSTRAINT ON (person:Person)\nASSERT person.uuid IS UNIQUE\n----\n\nAdd the uuid:\n\n.Test to see what happening... todo todo \n[source, cypher]\n----\nCALL apoc.uuid.install(\u0027Person\u0027)\n----\n\nSo each new node will have a uuid property.\n\nconfig: `addToExistingNodes` (adds the UUID to the nodes already existing in your graph),\n`uuidProperty` (the name of the name of the UUID field, by default is `uuid` )\n// todo - fare un esempio con uuidProperty\n\n\n.To remove a specific auto uuid\n[source, cypher]\n----\nCALL apoc.uuid.remove(\u0027LabelName\u0027)\n----\n\n.To remove all\n[source, cypher]\n----\nCALL apoc.uuid.removeAll()\n----\n\n.To get the list\n[source, cypher]\n----\nCALL apoc.uuid.list()\n----\n\n\u003d\u003d atomic props update:\n\n??? . sì ok, mah boh...\n\n\n\u003d\u003d locking\n\n\n\n\nThe examples in this section are based on the following sample graph:\n\n[source, bash]\n----\nCREATE (:Person {name:\u0027Alex\u0027})\nCREATE (:Email {address:\u0027alex@somewhere.com\u0027});\n----\n\n// todo - used to prevent some not-thread safety condition\n\nWe want to create exactly one HAS_EMAIL relationship between these nodes. We can use the MERGE clause to help us do this, but the MERGE clause isn’t thread safe, so we could have a situation where two nodes write the HAS_EMAIL relationship at the same time.\n// so exactly one write\n\nWe can prevent this race condition by using the apoc.lock.nodes procedure, as shown below:\n\n[source, bash]\n----\nMATCH (p:Person {name:\u0027Alex\u0027})\nMATCH (e:Email {address:\u0027alex@somewhere.com\u0027})\nCALL apoc.lock.nodes([p,e])\nMERGE (p)-[rel:HAS_EMAIL]-\u003e(e) // could have multiple writes without apoc.lock.nodes\nRETURN rel;\n----\n\n\n- apoc.lock.all([nodes],[relationships])\n- apoc.lock.nodes([nodes])\n- apoc.lock.rels([relationships]\n- apoc.lock.read.nodes\n- apoc.lock.read.rels\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-28 08:50:34.216",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d Temporal (Date Time)\u003c/p\u003e\n\u003cp\u003etodo - esempio per conversion\u003cbr /\u003e\ntodo 2 - integrarlo con parte di sopra\u003cbr /\u003e\n\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/temporal/\"\u003ehttps://neo4j.com/labs/apoc/4.1/temporal/\u003c/a\u003e \u0026ndash;\u0026gt; tanta roba\u0026hellip; solo alcune\u003c/p\u003e\n\u003cp\u003e\u003d\u003d Graph Updates\u003c/p\u003e\n\u003cp\u003e\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/graph-updates/\"\u003ehttps://neo4j.com/labs/apoc/4.1/graph-updates/\u003c/a\u003e \u0026ndash;\u0026gt; tanta roba\u0026hellip; solo alcune\u003cbr /\u003e\nCreating Data\u003cbr /\u003e\nGraph Refactorings\u003cbr /\u003e\nUUIDs\u003cbr /\u003e\nPeriodic Execution\u003cbr /\u003e\nAtomic Property Updates\u003cbr /\u003e\nLocking\u003cbr /\u003e\nTime To Live (TTL) - Expire Nodes\u003cbr /\u003e\nGenerating Graphs\u003cbr /\u003e\nDeleting Data\u003c/p\u003e\n\u003cp\u003e\u003d\u003d ttl\u003c/p\u003e\n\u003cp\u003eSome nodes are not meant to live forever. That’s why with APOC you can specify a time by when they are removed from the database, by utilizing a schema index and an additional label. A few procedures help with that.\u003c/p\u003e\n\u003cp\u003econf: to activate it \u0026ndash;\u0026gt;\u003cbr /\u003e\n[source, cypher]\u003cbr /\u003e\n\u003d\u003d\u003d\u003cbr /\u003e\napoc.ttl.enabled\u003dtrue\u0026lt;\u003cbr /\u003e\n# Optional: controls the repeat frequency\u003cbr /\u003e\n# apoc.ttl.schedule\u003d5\u0026gt;\u003cbr /\u003e\n\u003d\u003d\u003d\u003c/p\u003e\n\u003cp\u003eFor example (in a specific time): (params: node, epochTime, time unit (ms, s, m, h, d or millis, milliseconds, seconds, minutes, hours, days) )\u003cbr /\u003e\nMATCH (movie:Movie)\u0026lt;-[produced:PRODUCED]-(person:Person)\u003cbr /\u003e\nCALL apoc.ttl.expire(person,1585176720,\u0026lsquo;s\u0026rsquo;)\u003cbr /\u003e\nRETURN movie, produced, person\u003c/p\u003e\n\u003cp\u003eExpire after a periond(same syntax)\u003cbr /\u003e\nMATCH (movie:Movie)\u0026lt;-[directed:DIRECTED]-(person:Person)\u003cbr /\u003e\nCALL apoc.ttl.expireIn(person,120,\u0026lsquo;s\u0026rsquo;)\u003cbr /\u003e\nRETURN movie, directed, person\u003c/p\u003e\n\u003cp\u003eHow it works:\u003cbr /\u003e\nSet the :TTL label and ttl property on the node(s) you want to expire.\u003cbr /\u003e\n[sfondo grigio]\u003cbr /\u003e\nSET n:TTL\u003cbr /\u003e\nSET n.ttl \u003d timestamp() + 3600\u003cbr /\u003e\n[sfondo grigio]\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003eThe ttl property holds the time when the node is expired in milliseconds since epoch.\nCREATE INDEX ON :TTL(ttl)\n\nRemove node(s) that have passed the expiration time or length of time (through the apoc.ttl.schedule\u003d120)\nMATCH (t:TTL) where t.ttl \u0026lt; timestamp() WITH t LIMIT 1000 DETACH DELETE t\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ettl: emulato come MongoDb o Redis\u003c/p\u003e\n\u003cp\u003e\u003d\u003d uuid\u003cbr /\u003e\nautomation generation of UUIDs\u003c/p\u003e\n\u003cp\u003eIn 2 ways:\u003cbr /\u003e\nManual UUIDs: RETURN apoc.create.uuid() AS uuid; \u0026ndash;\u0026gt; e.g.: CREATE (p:Person {id: apoc.create.uuid()})\u003c/p\u003e\n\u003cp\u003eAuto UUID:\u003cbr /\u003e\nthrough 4 proc:\u003cbr /\u003e\napoc.uuid.install(\u0026lsquo;Label\u0026rsquo;, \u003ccode\u003e{configMap}\u003c/code\u003e)\u003c/p\u003e\n\u003ch2\u003eExample:\u003cbr /\u003e\nFirst of all, we need to create a constraint:\u003cbr /\u003e\n// todo - far vedere che succede se non lo installo\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCREATE CONSTRAINT ON (person:Person)\u003cbr /\u003e\nASSERT person.uuid IS UNIQUE\u003c/h2\u003e\n\u003cp\u003eAdd the uuid:\u003c/p\u003e\n\u003ch2\u003e.Test to see what happening\u0026hellip; todo todo\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.uuid.install(\u0026lsquo;Person\u0026rsquo;)\u003c/h2\u003e\n\u003cp\u003eSo each new node will have a uuid property.\u003c/p\u003e\n\u003cp\u003econfig: \u003ccode\u003eaddToExistingNodes\u003c/code\u003e (adds the UUID to the nodes already existing in your graph),\u003cbr /\u003e\n\u003ccode\u003euuidProperty\u003c/code\u003e (the name of the name of the UUID field, by default is \u003ccode\u003euuid\u003c/code\u003e )\u003cbr /\u003e\n// todo - fare un esempio con uuidProperty\u003c/p\u003e\n\u003ch2\u003e.To remove a specific auto uuid\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.uuid.remove(\u0026lsquo;LabelName\u0026rsquo;)\u003c/h2\u003e\n\u003ch2\u003e.To remove all\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.uuid.removeAll()\u003c/h2\u003e\n\u003ch2\u003e.To get the list\u003cbr /\u003e\n[source, cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.uuid.list()\u003c/h2\u003e\n\u003cp\u003e\u003d\u003d atomic props update:\u003c/p\u003e\n\u003cp\u003e??? . sì ok, mah boh\u0026hellip;\u003c/p\u003e\n\u003cp\u003e\u003d\u003d locking\u003c/p\u003e\n\u003cp\u003eThe examples in this section are based on the following sample graph:\u003c/p\u003e\n\u003ch2\u003e[source, bash]\u003c/h2\u003e\n\u003ch2\u003eCREATE (:Person {name:\u0026lsquo;Alex\u0026rsquo;})\u003cbr /\u003e\nCREATE (:Email {address:\u0026lsquo;\u003ca href\u003d\"mailto:alex@somewhere.com\"\u003ealex@somewhere.com\u003c/a\u003e\u0026rsquo;});\u003c/h2\u003e\n\u003cp\u003e// todo - used to prevent some not-thread safety condition\u003c/p\u003e\n\u003cp\u003eWe want to create exactly one HAS_EMAIL relationship between these nodes. We can use the MERGE clause to help us do this, but the MERGE clause isn’t thread safe, so we could have a situation where two nodes write the HAS_EMAIL relationship at the same time.\u003cbr /\u003e\n// so exactly one write\u003c/p\u003e\n\u003cp\u003eWe can prevent this race condition by using the apoc.lock.nodes procedure, as shown below:\u003c/p\u003e\n\u003ch2\u003e[source, bash]\u003c/h2\u003e\n\u003ch2\u003eMATCH (p:Person {name:\u0026lsquo;Alex\u0026rsquo;})\u003cbr /\u003e\nMATCH (e:Email {address:\u0026lsquo;\u003ca href\u003d\"mailto:alex@somewhere.com\"\u003ealex@somewhere.com\u003c/a\u003e\u0026rsquo;})\u003cbr /\u003e\nCALL apoc.lock.nodes([p,e])\u003cbr /\u003e\nMERGE (p)-[rel:HAS_EMAIL]-\u0026gt;(e) // could have multiple writes without apoc.lock.nodes\u003cbr /\u003e\nRETURN rel;\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003eapoc.lock.all([nodes],[relationships])\u003c/li\u003e\n\u003cli\u003eapoc.lock.nodes([nodes])\u003c/li\u003e\n\u003cli\u003eapoc.lock.rels([relationships]\u003c/li\u003e\n\u003cli\u003eapoc.lock.read.nodes\u003c/li\u003e\n\u003cli\u003eapoc.lock.read.rels\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635349807756_1469558743",
      "id": "paragraph_1635349807756_1469558743",
      "dateCreated": "2021-10-27 15:50:07.756",
      "dateStarted": "2021-10-28 08:50:34.230",
      "dateFinished": "2021-10-28 08:50:34.245",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n\u003d\u003d SCHEMA operations\n\n\n\nTo drop or create index or constraint, you can use the following procedure:\n\n[separator\u003d¦,opts\u003dheader,cols\u003d\"5,1m,1m\"]\n|\u003d\u003d\u003d\n¦Qualified Name¦Type¦Release\ninclude::example$generated-documentation/apoc.schema.assert.adoc[]\ninclude::example$generated-documentation/apoc.schema.nodes.adoc[]\ninclude::example$generated-documentation/apoc.schema.relationships.adoc[]\ninclude::example$generated-documentation/apoc.schema.node.constraintExists.adoc[]\ninclude::example$generated-documentation/apoc.schema.relationship.constraintExists.adoc[]\ninclude::example$generated-documentation/apoc.schema.node.indexExists.adoc[]\n|\u003d\u003d\u003d\n\n[source,cypher]\n----\nCALL apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true)\nYIELD label, key, keys, unique, action\n----\n\nWhere the outputs are:\n\n* label\n* key\n* keys, list of the key\n* unique, if the index or constraint are unique\n* action, can be the following values: DROPPED, CREATED\n\nTo retrieve indexes and constraints information for all the node labels in your database, you can use the following procedure:\n\n[source,cypher]\n----\nCALL apoc.schema.nodes()\nYIELD name, label, properties, status, type\n----\n\nWhere the outputs are:\n\n* name of the index/constraint,\n* label\n* properties, (for Neo4j 3.1 and lower versions is a single element array) that are affected by the constraint\n* status, for index can be one of the following values: ONLINE, POPULATING and FAILED\n* type, always \"INDEX\" for indexes, constraint type for constraints\n* failure, the failure description of a failed index\n* populationProgress, the population progress of the index in percentage\n* size, the size of the index\n* valuesSelectivity, computes the selectivity of the unique values\n* userDescription, a user friendly description of what this index indexes\n\nTo retrieve the constraint information for all the relationship types in your database, you can use the following procedure:\n\n[source,cypher]\n----\nCALL apoc.schema.relationships()\nYIELD name, type, properties, status\n----\n\nWhere the outputs are:\n\n* name of the constraint\n* type of the relationship\n* properties, (for Neo4j 3.1 and lower versions is a single element array) that are affected by the constraint\n* status\n\nConfig optional param is a map and its possible values are:\n\n* labels : list of labels to retrieve index/constraint information\n* excludeLabels: list of labels to exclude from retrieve index/constraint information\n* relationships: list of relationships type to retrieve constraint information\n* excludeRelationships: list of relationships\u0027 type to exclude from retrieve constraint information\n\n**Exclude has more power than include, so if excludeLabels and labels are both valued, procedure considers excludeLabels only, the same for relationships.**\n\n[source,cypher]\n----\nCALL apoc.schema.nodes({labels:[\u0027Book\u0027]})\nYIELD name, label, properties, status, type\n----\n\n\nN.B. Constraints for property existence on nodes and relationships are available only for the Enterprise Edition.\n\nTo retrieve the index existence on node, you can use the following user function:\n\n[source,cypher]\n----\nRETURN apoc.schema.node.indexExists(labelName, propertyNames)\n\n----\n\nThe output return the index existence on node is present or not\n\nTo retrieve if the constraint exists on node, you can use the following user function:\n\n[source,cypher]\n----\nRETURN apoc.schema.node.constraintExists(labelName, propertyNames)\n----\n\nThe output return the constraint existence on node.\n\nTo retrieve if the constraint exists on relationship, you can use the following user function:\n\n[source,cypher]\n----\nRETURN apoc.schema.relationship.constraintExists(type, propertyNames)\n----\n\nThe output return the constraint on the relationship is present or not\n\n\n\u003d\u003d\u003d Examples\n\n\u003d\u003d\u003d List Schema assert\n\nWhen you:\n\n[source,cypher]\n----\nCALL apoc.schema.assert({Foo:[\u0027bar\u0027]},null)\n----\n\nyou will receive this result:\n\nimage::apoc.schema.assert.index.png[scaledwidth\u003d\"100%\"]\n\nWhen you:\n\n[source,cypher]\n----\nCALL apoc.schema.assert(null,{Foo:[\u0027bar\u0027]})\n----\n\nyou will receive this result:\n\nimage::apoc.schema.assert.constraint.png[scaledwidth\u003d\"100%\"]\n\nWhen you:\n\n[source,cypher]\n----\nCALL apoc.schema.assert(null,null)\n----\n\nyou will receive this result:\n\nimage::apoc.schema.assert.drop.png[scaledwidth\u003d\"100%\"]\n\n\n\u003d\u003d\u003d List indexes and constraints for nodes\n\nGiven the following cypher statements:\n\n[source,cypher]\n----\nCREATE CONSTRAINT ON (bar:Bar) ASSERT exists(bar.foobar)\nCREATE CONSTRAINT ON (bar:Bar) ASSERT bar.foo IS UNIQUE\nCREATE INDEX ON :Person(name)\nCREATE INDEX ON :Publication(name)\nCREATE INDEX ON :Source(name)\n----\n\nWhen you\n\n[source,cypher]\n----\nCALL apoc.schema.nodes()\n----\n\n\nyou will receive this result:\n\nimage::apoc.schema.nodes.png[scaledwidth\u003d\"100%\"]\n\n\u003d\u003d\u003d List constraints for relationships\n\nGiven the following cypher statements:\n\n[source,cypher]\n----\nCREATE CONSTRAINT ON ()-[like:LIKED]-() ASSERT exists(like.day)\nCREATE CONSTRAINT ON ()-[starred:STARRED]-() ASSERT exists(starred.month)\n----\n\nWhen you\n\n[source,cypher]\n----\nCALL apoc.schema.relationships()\n----\n\nyou will receive this result:\n\nimage::apoc.schema.relationships.png[scaledwidth\u003d\"100%\"]\n\n\u003d\u003d\u003d Check if an index or a constraint exists for a Label and property\n\nGiven the previous index definitions, running this statement:\n\n[source,cypher]\n----\nRETURN apoc.schema.node.indexExists(\"Publication\", [\"name\"])\n----\nproduces the following output:\n\nimage::apoc.schema.node.indexExists.png[scaledwidth\u003d\"100%\"]\n\n\nGiven the previous constraint definitions, running this statement:\n\n[source,cypher]\n----\nRETURN apoc.schema.node.constraintExists(\"Bar\", [\"foobar\"])\n----\nproduces the following output:\n\nimage::apoc.schema.node.constraintExists.png[scaledwidth\u003d\"100%\"]\n\nIf you want to check if a constraint exists for a relationship you can run this statement:\n\n[source,cypher]\n----\nRETURN apoc.schema.relationship.constraintExists(\u0027LIKED\u0027, [\u0027day\u0027])\n----\n\nand you get the following result:\n\nimage::apoc.schema.relationship.constraintExists.png[scaledwidth\u003d\"100%\"]\n\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-28 15:53:57.223",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003cp\u003e\u003d\u003d SCHEMA operations\u003c/p\u003e\n\u003cp\u003eTo drop or create index or constraint, you can use the following procedure:\u003c/p\u003e\n\u003cp\u003e[separator\u003d¦,opts\u003dheader,cols\u003d\u0026ldquo;5,1m,1m\u0026rdquo;]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003cbr /\u003e\n¦Qualified Name¦Type¦Release\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.assert.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.nodes.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.relationships.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.node.constraintExists.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.relationship.constraintExists.adoc[]\u003cbr /\u003e\ninclude::example$generated-documentation/apoc.schema.node.indexExists.adoc[]\u003cbr /\u003e\n|\u003d\u003d\u003d\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.assert({indexLabel:\u003ca href\u003d\"indexKeys\"\u003eindexKeys\u003c/a\u003e, \u0026hellip;}, {constraintLabel:[constraintKeys], \u0026hellip;}, dropExisting : true)\u003cbr /\u003e\nYIELD label, key, keys, unique, action\u003c/h2\u003e\n\u003cp\u003eWhere the outputs are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elabel\u003c/li\u003e\n\u003cli\u003ekey\u003c/li\u003e\n\u003cli\u003ekeys, list of the key\u003c/li\u003e\n\u003cli\u003eunique, if the index or constraint are unique\u003c/li\u003e\n\u003cli\u003eaction, can be the following values: DROPPED, CREATED\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo retrieve indexes and constraints information for all the node labels in your database, you can use the following procedure:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.nodes()\u003cbr /\u003e\nYIELD name, label, properties, status, type\u003c/h2\u003e\n\u003cp\u003eWhere the outputs are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ename of the index/constraint,\u003c/li\u003e\n\u003cli\u003elabel\u003c/li\u003e\n\u003cli\u003eproperties, (for Neo4j 3.1 and lower versions is a single element array) that are affected by the constraint\u003c/li\u003e\n\u003cli\u003estatus, for index can be one of the following values: ONLINE, POPULATING and FAILED\u003c/li\u003e\n\u003cli\u003etype, always \u0026ldquo;INDEX\u0026rdquo; for indexes, constraint type for constraints\u003c/li\u003e\n\u003cli\u003efailure, the failure description of a failed index\u003c/li\u003e\n\u003cli\u003epopulationProgress, the population progress of the index in percentage\u003c/li\u003e\n\u003cli\u003esize, the size of the index\u003c/li\u003e\n\u003cli\u003evaluesSelectivity, computes the selectivity of the unique values\u003c/li\u003e\n\u003cli\u003euserDescription, a user friendly description of what this index indexes\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eTo retrieve the constraint information for all the relationship types in your database, you can use the following procedure:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.relationships()\u003cbr /\u003e\nYIELD name, type, properties, status\u003c/h2\u003e\n\u003cp\u003eWhere the outputs are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ename of the constraint\u003c/li\u003e\n\u003cli\u003etype of the relationship\u003c/li\u003e\n\u003cli\u003eproperties, (for Neo4j 3.1 and lower versions is a single element array) that are affected by the constraint\u003c/li\u003e\n\u003cli\u003estatus\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eConfig optional param is a map and its possible values are:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003elabels : list of labels to retrieve index/constraint information\u003c/li\u003e\n\u003cli\u003eexcludeLabels: list of labels to exclude from retrieve index/constraint information\u003c/li\u003e\n\u003cli\u003erelationships: list of relationships type to retrieve constraint information\u003c/li\u003e\n\u003cli\u003eexcludeRelationships: list of relationships\u0026rsquo; type to exclude from retrieve constraint information\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003eExclude has more power than include, so if excludeLabels and labels are both valued, procedure considers excludeLabels only, the same for relationships.\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.nodes({labels:[\u0026lsquo;Book\u0026rsquo;]})\u003cbr /\u003e\nYIELD name, label, properties, status, type\u003c/h2\u003e\n\u003cp\u003eN.B. Constraints for property existence on nodes and relationships are available only for the Enterprise Edition.\u003c/p\u003e\n\u003cp\u003eTo retrieve the index existence on node, you can use the following user function:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003cp\u003eRETURN apoc.schema.node.indexExists(labelName, propertyNames)\u003c/p\u003e\n\u003chr /\u003e\n\u003cp\u003eThe output return the index existence on node is present or not\u003c/p\u003e\n\u003cp\u003eTo retrieve if the constraint exists on node, you can use the following user function:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.schema.node.constraintExists(labelName, propertyNames)\u003c/h2\u003e\n\u003cp\u003eThe output return the constraint existence on node.\u003c/p\u003e\n\u003cp\u003eTo retrieve if the constraint exists on relationship, you can use the following user function:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.schema.relationship.constraintExists(type, propertyNames)\u003c/h2\u003e\n\u003cp\u003eThe output return the constraint on the relationship is present or not\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Examples\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d List Schema assert\u003c/p\u003e\n\u003cp\u003eWhen you:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.assert({Foo:[\u0026lsquo;bar\u0026rsquo;]},null)\u003c/h2\u003e\n\u003cp\u003eyou will receive this result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.assert.index.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003eWhen you:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.assert(null,{Foo:[\u0026lsquo;bar\u0026rsquo;]})\u003c/h2\u003e\n\u003cp\u003eyou will receive this result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.assert.constraint.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003eWhen you:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.assert(null,null)\u003c/h2\u003e\n\u003cp\u003eyou will receive this result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.assert.drop.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d List indexes and constraints for nodes\u003c/p\u003e\n\u003cp\u003eGiven the following cypher statements:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCREATE CONSTRAINT ON (bar:Bar) ASSERT exists(bar.foobar)\u003cbr /\u003e\nCREATE CONSTRAINT ON (bar:Bar) ASSERT bar.foo IS UNIQUE\u003cbr /\u003e\nCREATE INDEX ON :Person(name)\u003cbr /\u003e\nCREATE INDEX ON :Publication(name)\u003cbr /\u003e\nCREATE INDEX ON :Source(name)\u003c/h2\u003e\n\u003cp\u003eWhen you\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.nodes()\u003c/h2\u003e\n\u003cp\u003eyou will receive this result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.nodes.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d List constraints for relationships\u003c/p\u003e\n\u003cp\u003eGiven the following cypher statements:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCREATE CONSTRAINT ON ()-[like:LIKED]-() ASSERT exists(like.day)\u003cbr /\u003e\nCREATE CONSTRAINT ON ()-[starred:STARRED]-() ASSERT exists(starred.month)\u003c/h2\u003e\n\u003cp\u003eWhen you\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eCALL apoc.schema.relationships()\u003c/h2\u003e\n\u003cp\u003eyou will receive this result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.relationships.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003e\u003d\u003d\u003d Check if an index or a constraint exists for a Label and property\u003c/p\u003e\n\u003cp\u003eGiven the previous index definitions, running this statement:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.schema.node.indexExists(\u0026ldquo;Publication\u0026rdquo;, [\u0026ldquo;name\u0026rdquo;])\u003c/h2\u003e\n\u003cp\u003eproduces the following output:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.node.indexExists.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003eGiven the previous constraint definitions, running this statement:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.schema.node.constraintExists(\u0026ldquo;Bar\u0026rdquo;, [\u0026ldquo;foobar\u0026rdquo;])\u003c/h2\u003e\n\u003cp\u003eproduces the following output:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.node.constraintExists.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\u003cp\u003eIf you want to check if a constraint exists for a relationship you can run this statement:\u003c/p\u003e\n\u003ch2\u003e[source,cypher]\u003c/h2\u003e\n\u003ch2\u003eRETURN apoc.schema.relationship.constraintExists(\u0026lsquo;LIKED\u0026rsquo;, [\u0026lsquo;day\u0026rsquo;])\u003c/h2\u003e\n\u003cp\u003eand you get the following result:\u003c/p\u003e\n\u003cp\u003eimage::apoc.schema.relationship.constraintExists.png[scaledwidth\u003d\u0026ldquo;100%\u0026rdquo;]\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635376095899_1541463143",
      "id": "paragraph_1635376095899_1541463143",
      "dateCreated": "2021-10-27 23:08:15.899",
      "dateStarted": "2021-10-28 15:53:57.220",
      "dateFinished": "2021-10-28 15:53:57.273",
      "status": "FINISHED"
    },
    {
      "text": "%md\n\n# todo - docker img\n- Jdbc (apoc.load.jdbc)\n- Elastic search (load.es.*)\n- MongoDb (apoc.mongo.*)\n- Couchbase (apoc.couchbase.*): https://neo4j.com/labs/apoc/4.1/database-integration/couchbase/\n- Load Ldap (apoc.load.ldap)\n- Bolt\n```\nCALL apoc.bolt.execute(urlOrKey, statement, params, config) YIELD row - access to other databases via bolt for read and write\n\nCALL apoc.bolt.load(urlOrKey, statement, params, config) YIELD row - access to other databases via bolt for read\n```\n\n\n\nTo execute jdbc procedure you have to download the correspondig jdbc driver and put in `plugin` folder:\nhere is the list of privided driver (https://neo4j.com/labs/apoc/4.1/database-integration/load-jdbc/#_load_jdbc_resources)\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 11:00:09.718",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": true,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/markdown",
        "editorHide": true,
        "tableHide": false
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "SUCCESS",
        "msg": [
          {
            "type": "HTML",
            "data": "\u003cdiv class\u003d\"markdown-body\"\u003e\n\u003ch1\u003etodo - docker img\u003c/h1\u003e\n\u003cul\u003e\n\u003cli\u003eJdbc (apoc.load.jdbc)\u003c/li\u003e\n\u003cli\u003eElastic search (load.es.*)\u003c/li\u003e\n\u003cli\u003eMongoDb (apoc.mongo.*)\u003c/li\u003e\n\u003cli\u003eCouchbase (apoc.couchbase.*): \u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/database-integration/couchbase/\"\u003ehttps://neo4j.com/labs/apoc/4.1/database-integration/couchbase/\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003eLoad Ldap (apoc.load.ldap)\u003c/li\u003e\n\u003cli\u003eBolt\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode\u003eCALL apoc.bolt.execute(urlOrKey, statement, params, config) YIELD row - access to other databases via bolt for read and write\n\nCALL apoc.bolt.load(urlOrKey, statement, params, config) YIELD row - access to other databases via bolt for read\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo execute jdbc procedure you have to download the correspondig jdbc driver and put in \u003ccode\u003eplugin\u003c/code\u003e folder:\u003cbr /\u003e\nhere is the list of privided driver (\u003ca href\u003d\"https://neo4j.com/labs/apoc/4.1/database-integration/load-jdbc/#_load_jdbc_resources\"\u003ehttps://neo4j.com/labs/apoc/4.1/database-integration/load-jdbc/#_load_jdbc_resources\u003c/a\u003e)\u003c/p\u003e\n\n\u003c/div\u003e"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635436437219_504267999",
      "id": "paragraph_1635436437219_504267999",
      "dateCreated": "2021-10-28 15:53:57.219",
      "dateStarted": "2021-10-29 11:00:09.718",
      "dateFinished": "2021-10-29 11:00:09.740",
      "status": "FINISHED"
    },
    {
      "text": "%neo4j\n// todo - non va...\nWITH \"jdbc:postgresql://localhost:55005/docker\" as url\nCALL apoc.load.jdbc(url,\u0027event\u0027,[], {credentials: {user: \u0027docker\u0027, password: \u0027docker\u0027 } })\nYIELD row RETURN row",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 11:00:21.204",
      "config": {
        "colWidth": 12.0,
        "fontSize": 9.0,
        "enabled": true,
        "results": {},
        "editorSetting": {
          "editOnDblClick": false,
          "language": "markdown",
          "completionSupport": false
        },
        "editorMode": "ace/mode/undefined"
      },
      "settings": {
        "params": {},
        "forms": {}
      },
      "results": {
        "code": "ERROR",
        "msg": [
          {
            "type": "TEXT",
            "data": "Failed to invoke procedure `apoc.load.jdbc`: Caused by: java.net.ConnectException: Connection refused (Connection refused)"
          }
        ]
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635504607355_773522466",
      "id": "paragraph_1635504607355_773522466",
      "dateCreated": "2021-10-29 10:50:07.355",
      "dateStarted": "2021-10-29 11:00:21.220",
      "dateFinished": "2021-10-29 11:00:21.259",
      "status": "ERROR"
    },
    {
      "text": "%neo4j\n",
      "user": "anonymous",
      "dateUpdated": "2021-10-29 10:52:59.979",
      "config": {},
      "settings": {
        "params": {},
        "forms": {}
      },
      "apps": [],
      "runtimeInfos": {},
      "progressUpdateIntervalMs": 500,
      "jobName": "paragraph_1635504779978_1876755451",
      "id": "paragraph_1635504779978_1876755451",
      "dateCreated": "2021-10-29 10:52:59.978",
      "status": "READY"
    }
  ],
  "name": "others",
  "id": "2GK4BTA5G",
  "defaultInterpreterGroup": "neo4j",
  "version": "0.9.0-preview2",
  "noteParams": {},
  "noteForms": {},
  "angularObjects": {},
  "config": {
    "isZeppelinNotebookCronEnable": false
  },
  "info": {}
}